<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>敏思·践行</title>
  
  <subtitle>有关思维、技术和生活的絮叨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://johntse.dev/"/>
  <updated>2020-05-10T07:10:15.488Z</updated>
  <id>https://johntse.dev/</id>
  
  <author>
    <name>John Tse</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Programmer&#39;s Oath</title>
    <link href="https://johntse.dev/the-programmers-oath/"/>
    <id>https://johntse.dev/the-programmers-oath/</id>
    <published>2019-10-25T01:06:36.000Z</published>
    <updated>2020-05-10T07:10:15.488Z</updated>
    
    <content type="html"><![CDATA[<p>程序员宣言，来源于Robert Martin（或者称为Bob大叔，软件开发理论巨头之一。其中最为世人所知的：敏捷宣言，SOLID原则）。</p><a id="more"></a><p>原文：<a href="https://blog.cleancoder.com/uncle-bob/2015/11/18/TheProgrammersOath.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2015/11/18/TheProgrammersOath.html</a></p><p>为了捍卫和维护计算机程序员的职业荣誉，我承诺，尽我所能和判断力：</p><p>（In order to defend and preserve the honor of the profession of computer programmers, I Promise that, to the best of my ability and judgement:）</p><ol><li>我不会生成有害性的代码（I will not produce harmful code）</li><li>我生成的代码永远是我最好的作品。我不会明知故犯地增加任何无论行为上还是结构上有缺陷的代码（The code that I produce will always be my best work. I will not knowingly allow code that is defective either in behavior or structure to accumulate）</li><li>每次发布时，我要生成一份快速，可靠和可重复验证的证据，来确保代码的每个元素都应该是正常工作的（I will produce, with each release, a quick, sure, and repeatable proof that every element of the code works as it should）</li><li>我要经常做小版本发布，这样我就不会妨碍其他人的进度（I will make frequent, small, releases so that I do not impede the progress of others）</li><li>我要抓住每个机会，努力不懈地改进我的作品，我永远不会让它们退化（I will fearlessly and relentlessly improve my creations at every opportunity, I will never degrade them）</li><li>我要尽我所能地保持自己和其他人的生产力。我不会做任何有损生成力的事（I will do all that I can to keep the productivity of myself, and others, as high as possible. I will do nothing that decrease that productivity）</li><li>我要持续地确保有人能够支持我的工作，我也能支持他们的工作（I will continuously ensure that others can cover for me, and that I can cover for them）</li><li>我要在数量和精度上做出诚实的估计，不做毫无把握的承诺（I will produce estimates that are honest both in magnitude and percision. I will not make promises without certainly）</li><li>我永远不会停止学习和改进我的手艺（I will never stop learning and improving my craft）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序员宣言，来源于Robert Martin（或者称为Bob大叔，软件开发理论巨头之一。其中最为世人所知的：敏捷宣言，SOLID原则）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thinking" scheme="https://johntse.dev/categories/thinking/"/>
    
    
      <category term="programmer" scheme="https://johntse.dev/tags/programmer/"/>
    
      <category term="faith" scheme="https://johntse.dev/tags/faith/"/>
    
  </entry>
  
  <entry>
    <title>反向面试</title>
    <link href="https://johntse.dev/reverse-interview/"/>
    <id>https://johntse.dev/reverse-interview/</id>
    <published>2019-09-17T07:13:18.000Z</published>
    <updated>2020-05-10T07:16:23.773Z</updated>
    
    <content type="html"><![CDATA[<p>所谓反向面试，即是面试者在面试最后访问面试官的问题。这个环节，一般面试者经常忽略，面试是一个双向的过程。好的问题，可以是让自己尽早避开一些坑。但是从本人作为面试官的经历来看，面试者经常关注的问题往往是加班、出差或者薪资水平，而对于技术氛围、工作内容、基础设施、公司发展模式等比较影响自己工作体验和成长的部分却很少关心。</p><a id="more"></a><p>原文链接：<a href="https://github.com/viraptor/reverse-interview" target="_blank" rel="noopener">https://github.com/viraptor/reverse-interview</a>。</p><p>以下为<a href="https://github.com/yifeikong/reverse-interview-zh" target="_blank" rel="noopener">yifeikong</a>的翻译。</p><p>下面列表里的问题对于参加技术面试的人来说可能有些用。 列表里的问题并不一定适用于某个特定的职位或者工作类型, 也没有排序 最开始的时候这只是我自己的问题列表, 但是慢慢地添加了一些我觉得可能让我对这家公司亮红牌的问题。 我也注意到被我面试的人提问我的问题太少了, 感觉他们挺浪费机会的。</p><p>如果你问过的问题没有被列出来, 请提交一个 PR。</p><h2 id="预期使用方式"><a href="#预期使用方式" class="headerlink" title="预期使用方式"></a>预期使用方式</h2><ul><li>检查一下哪些问题你感兴趣</li><li>检查一下哪些是你可以自己在网上找到答案的</li><li>找不到的话就像面试官提问</li></ul><p>绝对不要想把这个列表里的每个问题都问一遍。</p><p>请记住事情总是灵活的，组织的结构调整也会经常发生。 拥有一个 bug 追踪系统并不会保证高效处理 bug。CI/CD (持续集成系统) 也不一定保证交付时间会很短。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><ul><li>On-call (电话值班)的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？</li><li>我的日常工作是什么？</li><li>团队里面初级和高级工程师的比例是多少？（有计划改变吗）</li><li>入职培训会是什么样的？</li><li>自己单独的开发活动和按部就班工作的比例大概是怎样的？</li><li>每天预期/核心工作时间是多少小时？</li><li>在你看来，这个工作做到什么程度算成功？</li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>公司常用的技术栈是什么?</li><li>你们怎么是使用源码控制系统？</li><li>你们怎么测试代码？</li><li>你们怎么追踪 bug?</li><li>你们怎么集成和部署代码改动？是使用持续集成和持续部署吗？</li><li>你们的基础设施搭建方法在版本管理系统里吗？或者是代码化的吗？</li><li>从计划到完成一项任务的工作流是什么样的？</li><li>你们如何准备故障恢复？</li><li>有标准的开发环境吗？是强制的吗？</li><li>你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟/小时/天）</li><li>你们需要花费多长时间来响应代码或者依赖中的安全问题？</li><li>所有的开发者都可以使用他们电脑的本地管理员权限吗？</li></ul><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><ul><li>工作是怎么组织的？</li><li>团队内/团队间的交流通常是怎样的？</li><li>如果遇到不同的意见怎样处理？</li><li>谁来设定优先级 / 计划？</li><li>如果被退回了会怎样？（“这个在预计的时间内做不完”）</li><li>每周都会开什么类型的会议？</li><li>产品/服务的规划是什么样的？（n周一发布 / 持续部署 / 多个发布流 / …)</li><li>生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？</li><li>有没有一些团队正在经历还尚待解决的挑战？</li></ul><h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><ul><li>有没有会议/旅行预算？使用的规定是什么？</li><li>晋升流程是怎样的？要求/预期是怎样沟通的？</li><li>技术和管理两条职业路径是分开的吗？</li><li>对于多元化招聘的现状或者观点是什么？</li><li>有公司级别的学习资源吗？比如电子书订阅或者在线课程？</li><li>有获取证书的预算吗？</li><li>公司的成熟度如何？（早期寻找方向 / 有内容的工作 / 维护中 / …)</li><li>我可以为开源项目做贡献吗？是否需要审批？</li><li>有竞业限制或者保密协议需要签吗？</li><li>你们认为公司文化中的空白是什么？</li><li>能够跟我说一公司处于不良情况，以及愈合处理的故事吗？</li></ul><h2 id="商业"><a href="#商业" class="headerlink" title="商业"></a>商业</h2><ul><li>你们现在盈利吗？</li><li>如果没有的话，还需要多久？</li><li>公司的资金来源是什么？谁影响或者指定高层计划或方向？</li><li>你们如何挣钱？</li><li>什么阻止了你们挣更多的钱？</li><li>你们认为什么是你们的竞争优势？</li></ul><h2 id="远程工作"><a href="#远程工作" class="headerlink" title="远程工作"></a>远程工作</h2><ul><li>远程工作和办公室工作的比例是多少？</li><li>公司提供硬件吗？更新计划如何？</li><li>额外的附件和家居可以通过公司购买吗？这方面是否有预算？</li><li>有共享办公或者上网的预算吗？</li><li>多久需要去一次办公室？</li><li>公司的会议室是否一致为视频会议准备着？</li></ul><h2 id="办公室工作"><a href="#办公室工作" class="headerlink" title="办公室工作"></a>办公室工作</h2><ul><li>办公室的布局如何？（开放的 / 小隔间 / 独立办公室）</li><li>有没有支持/市场/或者其他需要大量打电话的团队在我的团队旁边办公吗？</li></ul><h2 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h2><ul><li>如果有奖金计划的话，奖金如何分配？</li><li>如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？</li><li>有五险一金或者其他退休养老金等福利吗？如果有的话，公司有配套的商业保险吗？</li></ul><h2 id="带薪休假"><a href="#带薪休假" class="headerlink" title="带薪休假"></a>带薪休假</h2><ul><li>带薪休假时间有多久？</li><li>病假和事假是分开的还是一起算？</li><li>我可以提前使用假期时间吗？也就是说应休假期是负的？</li><li>假期的如何滚动更新？也就是说未休的假期能否滚入下一周期</li><li>照顾小孩的政策如何？</li><li>无薪休假政策是什么样的？</li></ul><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul><li>可以在 <a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/" target="_blank" rel="noopener">Joel Test</a> 找到更多灵感。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓反向面试，即是面试者在面试最后访问面试官的问题。这个环节，一般面试者经常忽略，面试是一个双向的过程。好的问题，可以是让自己尽早避开一些坑。但是从本人作为面试官的经历来看，面试者经常关注的问题往往是加班、出差或者薪资水平，而对于技术氛围、工作内容、基础设施、公司发展模式等比较影响自己工作体验和成长的部分却很少关心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="soft skills" scheme="https://johntse.dev/categories/soft-skills/"/>
    
    
      <category term="interview" scheme="https://johntse.dev/tags/interview/"/>
    
      <category term="job" scheme="https://johntse.dev/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个优秀的软件设计文档</title>
    <link href="https://johntse.dev/how-to-write-an-excellent-software-design-document/"/>
    <id>https://johntse.dev/how-to-write-an-excellent-software-design-document/</id>
    <published>2019-08-27T07:00:29.000Z</published>
    <updated>2020-05-10T07:04:52.796Z</updated>
    
    <content type="html"><![CDATA[<p>国外互联网是如何编写设计文档的，其中重要的是量化和风险尽早发现和解决。</p><a id="more"></a><p><em>update 2020/5/8 Google最近给出了一个技术写作课程《<a href="https://developer.google.com/tech-writing/overview" target="_blank" rel="noopener">Technical Writing</a>》。</em></p><p>原文链接：<a href="https://www.freecodecamp.com/news/how-to-write-a-good-software-design-document-66fcf019569c" target="_blank" rel="noopener">How to write a good software design doc</a></p><h2 id="为什么要写设计文档"><a href="#为什么要写设计文档" class="headerlink" title="为什么要写设计文档"></a>为什么要写设计文档</h2><blockquote><p>A design doc is the most useful tool for making sure the right work gets done.</p></blockquote><p>写设计文档可以帮助自己理清任务和确定方案（减少和避免后期返工的风险和成本），也是开发人员之间互相交流和协调工作的媒介。</p><h2 id="设计文档中应该包含什么"><a href="#设计文档中应该包含什么" class="headerlink" title="设计文档中应该包含什么"></a>设计文档中应该包含什么</h2><h3 id="标题和人"><a href="#标题和人" class="headerlink" title="标题和人"></a>标题和人</h3><p>其中人包括了作者（可能多个，同时这些人也是参与到该项目中的人员）、评审人员，同时也要包含文档最新更新时间。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>言简意赅地介绍这个设计文档中的内容。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>说明一下需要解决的问题，项目的必要性，了解项目所需的背景知识，是否满足公司的技术策略、产品策略或者季度目标。</p><h3 id="目标和非目标"><a href="#目标和非目标" class="headerlink" title="目标和非目标"></a>目标和非目标</h3><p>对于目标部分，需要描述该项目对用户（包括其它项目组、其它部门，甚至其它系统）的影响，以及如何使用相关指标来衡量项目的成功与否。</p><p>对于非目标部分，需要描述那些你不打算解决的问题。</p><h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>给出一系列可度量的检查点。如果项目周期超过一个月的话，可以设置一些面向用户的里程碑来讲项目进行切分。这样无论对于PM还是利益干系人都能够及时地知道进度。</p><h3 id="已有方案"><a href="#已有方案" class="headerlink" title="已有方案"></a>已有方案</h3><p>给出当前实现的流程、交互或者数据流，同时最好给出相关的用户故事。</p><h3 id="建议方案"><a href="#建议方案" class="headerlink" title="建议方案"></a>建议方案</h3><p>同样给出相关的用户故事，并且给出总体设计，细节部分可以后续补充。</p><h3 id="其它可选方案"><a href="#其它可选方案" class="headerlink" title="其它可选方案"></a>其它可选方案</h3><p>可以给出一些其它可选方案，以及它们的优势和劣势。</p><h3 id="可测试性、监控和预警"><a href="#可测试性、监控和预警" class="headerlink" title="可测试性、监控和预警"></a>可测试性、监控和预警</h3><p>这部分往往被忽略，或者事后补充。</p><h3 id="部门间影响"><a href="#部门间影响" class="headerlink" title="部门间影响"></a>部门间影响</h3><p>需要考虑该项目对‘上下游的影响，如何应对。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>可以列出一些不确定的问题，后续工作，设计上待改进的地方等等。</p><h3 id="详细地项目范围和时间表"><a href="#详细地项目范围和时间表" class="headerlink" title="详细地项目范围和时间表"></a>详细地项目范围和时间表</h3><p>这部分个人觉得应该放到其它部分，设计文档中可不写。</p><h2 id="如何编写设计文档"><a href="#如何编写设计文档" class="headerlink" title="如何编写设计文档"></a>如何编写设计文档</h2><h3 id="简单化"><a href="#简单化" class="headerlink" title="简单化"></a>简单化</h3><ul><li>用词简单</li><li>避免长篇大论</li><li>多采用列表</li><li>给出具体示例</li></ul><h3 id="多加一些图表"><a href="#多加一些图表" class="headerlink" title="多加一些图表"></a>多加一些图表</h3><p>最好是可编辑的图表，方便更新。</p><h3 id="用数据说话"><a href="#用数据说话" class="headerlink" title="用数据说话"></a>用数据说话</h3><p>给出一些真实数据，可以更好地帮助别人了解问题和方案。</p><h3 id="试着有趣一点"><a href="#试着有趣一点" class="headerlink" title="试着有趣一点"></a>试着有趣一点</h3><p>设计文档不是学术论文，不需要很严肃。但也要避免过犹不及。</p><h3 id="做一些测试"><a href="#做一些测试" class="headerlink" title="做一些测试"></a>做一些测试</h3><p>写完后，不要急着评审，自己从评审角度去审阅自己的设计，然后不断地解决设计中的问题和疑问。</p><h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><p><em>只要实现还在进行，那么设计文档也应该保持同步更新。</em></p><h3 id="关于设计"><a href="#关于设计" class="headerlink" title="关于设计"></a>关于设计</h3><ol><li>设计文档可以给你一些反馈，避免自己浪费大量时间实现错误的方案或者解决错误的问题。</li><li>项目中的每个人都是设计过程中的一部分。</li><li>设计过程不是理论空想，你应该不断去验证想法，可以试图搞一些试验代码来进行验证</li></ol><h3 id="开始设计之前你应该"><a href="#开始设计之前你应该" class="headerlink" title="开始设计之前你应该"></a>开始设计之前你应该</h3><p>这些事情可以让你尽早地得到反馈，发现问题和节省时间。</p><ol><li>向有经验的工程师或者技术经理请教或者邀请他们对你的想法进行点评</li><li>向他描述你要解决的问题</li><li>解释你是如何实现的，并试图说服他</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国外互联网是如何编写设计文档的，其中重要的是量化和风险尽早发现和解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="soft skills" scheme="https://johntse.dev/categories/soft-skills/"/>
    
    
      <category term="design" scheme="https://johntse.dev/tags/design/"/>
    
      <category term="write" scheme="https://johntse.dev/tags/write/"/>
    
  </entry>
  
  <entry>
    <title>一次数据查询设计实现始末</title>
    <link href="https://johntse.dev/a-index-for-data-query-design-and-implementation/"/>
    <id>https://johntse.dev/a-index-for-data-query-design-and-implementation/</id>
    <published>2019-07-22T14:00:47.000Z</published>
    <updated>2020-05-10T04:43:40.144Z</updated>
    
    <content type="html"><![CDATA[<p>现有一文本文件，文件内容每行记录由3个字段组成，字段间以’\t’分隔，每行以’\n’分隔，3个字段分别为”身份证号码 手机号码 姓名“。现需要提供一个服务，业务可通过服务根据身份证号码或者手机号码精确查询相关记录。那么如何设计，使得查询响应延迟低、吞吐高和资源消耗低。</p><a id="more"></a><h2 id="一、数据分析"><a href="#一、数据分析" class="headerlink" title="一、数据分析"></a>一、数据分析</h2><h3 id="1-数据总量"><a href="#1-数据总量" class="headerlink" title="1. 数据总量"></a>1. 数据总量</h3><p>“10亿条由身份证号码、手机号码和姓名组成的记录”，如果这些记录以文本格式存储，那么</p><ul><li>身份证号码为定长记录，需要18个字节表示</li><li>手机号码为定长记录，需要11个字节表示</li><li>姓名为变长记录，假设平均一个姓名需要3个汉字来表示，并且使用UTF8编码。那么则姓名平均需要9个字节表示</li><li>每行记录包含三个’\t’和一个’\n’，需要4个字节表示</li></ul><p>总共则需要$(18 + 11 + 9 + 4 ) × 1000000000$字节来进行存储，即整个记录文件大小大约有39.2GB。而这些记录如果全部装载入内存，则至少需要$(18 + 11 + 9 ) × 1000000000$字节，约35.4GB。如果使用Java实现，还需要考虑到额外的存储占用。</p><h3 id="2-身份证号码"><a href="#2-身份证号码" class="headerlink" title="2. 身份证号码"></a>2. 身份证号码</h3><p><em>这里的身份证号码统一指中华人员共和国公民身份证上给出的公民身份号码。</em></p><p>该号码格式：</p><blockquote><p>六位地址码+八位出生日期码(yyyyMMdd)+三位顺序码+一位校验码</p></blockquote><table><thead><tr><th>码号</th><th>值域</th><th>总数</th><th>说明</th></tr></thead><tbody><tr><td>地址码</td><td>N/A</td><td>&lt;32000</td><td>六位行政区划代码（不包括港澳台）。<br>理论总数不超过310000个，实际上不超过32000个</td></tr><tr><td>出生日期码</td><td>[19000101, $\infty$]</td><td>365×年数</td><td>理论上无限个，但实际（截止2019年）已有的不超过43800</td></tr><tr><td>顺序码</td><td>[000, 999]</td><td>1000</td><td></td></tr><tr><td>校验码</td><td>[0, 10]</td><td>11</td><td>实际应用中，10使用<code>X</code>进行表示</td></tr></tbody></table><p>截止今年（2019），身份证号码的理论值域空间大小不超过1401600000000，但实际不会超过1500000000。</p><p>其中，校验码可以由前面17位数字通过算法计算得到（具体算法参见附录）。因此，实际存储时可以去掉。这样记录中一个身份证就可以使用长整型来表示，那么单个身份证号码存储就可以节省10个字节。这样，记录中的身份证号码存储至多需要7.5GB。</p><h3 id="3-手机号码"><a href="#3-手机号码" class="headerlink" title="3. 手机号码"></a>3. 手机号码</h3><p><em>这里的手机号码统一指中华人民共和国大陆地区手机所用号码</em></p><p>该号码格式：</p><blockquote><p>三位网络识别码+四位地区码+四位用户号码</p></blockquote><table><thead><tr><th>码号</th><th>值域</th><th>总数</th><th>说明</th></tr></thead><tbody><tr><td>网络识别码</td><td>N/A</td><td>&lt;60</td><td>主要包括电信、移动和联通三大运营商</td></tr><tr><td>地区码</td><td>[0000, 9999]</td><td>10000</td><td>可用于识别手机号码归属地</td></tr><tr><td>用户号码</td><td>[0000, 9999]</td><td>10000</td><td>随机分配</td></tr></tbody></table><p>手机号码的理论值域空间大小不超过6000000000。可以看出手机号码的值域空间比身份证号码的要大，换句话说，记录中身份证号码重复的可能性要比手机号码更高。</p><p>由于手机号码由纯数字组成，这样记录中的一个手机号码就可以使用长整型来表示，那么单个手机号码存储就可以节省7个字节。这样，记录中的手机号码存储至多需要7.5GB。</p><h3 id="4-姓名"><a href="#4-姓名" class="headerlink" title="4. 姓名"></a>4. 姓名</h3><p>我国是个多民族国家，虽然姓名组成比较复杂，但姓名的重复率还是很高的。比如常见的“王伟”，“张伟”等。特别地，在<code>&lt;身份证号码，手机号码，姓名&gt;</code>三元组中，可能会存在一个身份证号码对应多个手机号码的情况，使得姓名的重复率进一步上升。而姓名的值域空间大小则不会超过当前中国人口大小（&lt;15亿）。</p><p>这里我们可以将数据中的姓名取出并进行去重处理，同时可以使用一个整型来对去重后的姓名进行编码。这样记录中一个姓名可以使用编码后的一个整型值表示，那么单个姓名存储就可以固定为4个字节。这样，记录中的姓名存储（包括编码和姓名本身）至多需要（假设记录中姓名去重后最多有一亿个）1.2GB。</p><p>当然，也可以进一步地将姓名拆分为单个汉字去重后编码，但这样编码后，复杂度上升，单个姓名长度不再固定，每个汉字编码后占用2个字节，这样算下来实际节省空间也没有提高多少。</p><h2 id="二、存储设计"><a href="#二、存储设计" class="headerlink" title="二、存储设计"></a>二、存储设计</h2><p>通过数据分析后，我们发现如果采用数据全部加载到内存的方式，对整个资源要求是比较高的。因此，自然会想到将“一部分”数据放在内存，“另一部分”数据放在磁盘上。但关键在于哪部分数据在内存，哪部分在磁盘，并且需要解决以下问题：</p><ul><li>内存中的数据如何组织</li><li>如何从较慢的磁盘上快速地读取数据</li><li>数据如何缓存和淘汰</li></ul><p>该章节我们先来主要回答前两个问题，第三个问题在下一个章节中描述。</p><h3 id="1-磁盘文件格式"><a href="#1-磁盘文件格式" class="headerlink" title="1. 磁盘文件格式"></a>1. 磁盘文件格式</h3><p>为了能够在磁盘文件中能够更快的读取内存中不存在的记录，设计时应：</p><ul><li>磁盘文件尽可能紧凑（体积尽可能小），这样每次I/O读取到尽可能多的记录</li><li>能够快速定位记录在文件中的位置（偏移量）</li></ul><p>因此，为了能够满足这些要求，磁盘文件格式设计为二进制格式。</p><h4 id="身份证号码可索引文件"><a href="#身份证号码可索引文件" class="headerlink" title="身份证号码可索引文件"></a>身份证号码可索引文件</h4><p>用于通过身份证号码检索记录的场景。</p><h5 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h5><img src="/a-index-for-data-query-design-and-implementation/索引总体结构.png" title="索引总体结构"><p>通过一级和二级索引，能够快速定位记录在文件中的位置。</p><h5 id="元数据结构"><a href="#元数据结构" class="headerlink" title="元数据结构"></a>元数据结构</h5><img src="/a-index-for-data-query-design-and-implementation/元数据结构.png" title="元数据结构"><p>从左到右依次是：</p><ul><li><code>Len</code>表示文件所采用的编码字符串长度，比如”utf8“长度为4</li><li><code>Charset</code>表示文件所采用的具体编码，比如”utf8“</li><li><code>idx</code>表示索引字段下标，即构建该索引文件时读取的文本文件中索引字段所在下标</li><li><code>Range</code>表示如何对索引字段进行划分，用于构建二级索引。其中第一个表示一级索引中key如何得到及其所占用字节数，第二个表示二级索引中key如何得到及其所占用字节数，第三个表示内容中每条记录前缀如何得到及其所占用字节数<ul><li><code>Start</code>表示取值时在索引字段中的起始位置（包含）</li><li><code>End</code>表示取值时在索引字段中的结束位置（包含）</li><li><code>Size</code>表示该Range表示的值存储时所占用字节数</li></ul></li><li><code>FieldNum</code>表示内容中每条记录由多少个字段组成</li><li><code>FieldSize</code>表示内容中每条记录所占用字节数<ul><li><code>Index</code>表示记录中第几个字段</li><li><code>Size</code>表示记录中相应字段所占用字节数</li></ul></li><li><code>Length</code>表示整个元数据（不包含Length所占用的4个字节）的长度</li></ul><p>元数据的作用在于其中的信息可用于指导程序正确地解析二进制文件。</p><h5 id="一级索引结构"><a href="#一级索引结构" class="headerlink" title="一级索引结构"></a>一级索引结构</h5><img src="/a-index-for-data-query-design-and-implementation/身份证一级索引结构.png" title="身份证一级索引结构"><p>从左到右依次是：</p><ul><li><code>Num</code>表示一级索引中的索引条目数量，最大支持32767个</li><li><code>Range1</code>表示通过元数据中第一个Range描述由索引字段生成的值，每个值是唯一的</li><li><code>Offset</code>表示符合Range1值的二级索引在文件中的位置（偏移量）</li><li><code>Length</code>表示整个一级索引（不包含Length所占用的4个字节）的长度</li></ul><p>一级索引的作用在于能够根据索引字段的部分信息先缩小需要读取的数据范围。</p><h5 id="二级索引结构"><a href="#二级索引结构" class="headerlink" title="二级索引结构"></a>二级索引结构</h5><img src="/a-index-for-data-query-design-and-implementation/身份证二级索引结构.png" title="身份证二级索引结构"><p>从左到右依次是：</p><ul><li><code>Num</code>表示二级索引中的索引条目数量，最大支持32767个</li><li><code>Range2</code>表示元数据中第二个Range描述由索引字段生成的值，每个值是唯一的</li><li><code>Num</code>表示符合Range2值的记录数，最大支持16777215个</li><li><code>Offset</code>表示Range2值的第一条记录在文件中的位置（偏移量），最大支持1TB大小文件</li><li><code>Length</code>表示整个二级索引（不包含Length所占用的4个字节）的长度</li></ul><p>二级索引的作用在于能够根据索引字段的部分信息进一步缩小需要读取的数据范围，并定位到符合要求的记录可能的位置。</p><h5 id="内容结构"><a href="#内容结构" class="headerlink" title="内容结构"></a>内容结构</h5><img src="/a-index-for-data-query-design-and-implementation/身份证索引内容结构.png" title="身份证索引内容结构"><p>从左到右依次是：</p><ul><li><code>Range3</code>表示元数据中第三个Range描述由索引字段生成的值，每个值是唯一的</li><li><code>Phone Num</code>表示一个手机号码</li><li><code>Name Seq</code>表示姓名编号</li></ul><p>每个二级索引下的记录按照Range3值排序，这样可以方便进行最后的快速检索。</p><h5 id="索引文件构建"><a href="#索引文件构建" class="headerlink" title="索引文件构建"></a>索引文件构建</h5><p>索引构建时需要对原始数据做一定的处理。</p><ol><li>提取出原始数据中姓名字段，并生成姓名索引文件$Name_{index}$和姓名编码文件$Name_{code}$</li><li>使用姓名编码文件$Name_{code}$中的编码替换原始数据中的姓名，生成文件$SF_1$</li><li>对文件$SF_1$中的身份证号码字段进行切分，按照一级索引、二级索引和内容前缀的顺序并使用”,”重新拼接，生成文件$SF_2$</li><li>对文件$SF2$中的记录按照重新组合后的身份证号码进行排序，生成文件$SF_3$</li><li>对文件$SF3$进行处理，生成最终的身份证号码可索引文件$Index_{sfz}$</li></ol><p>假设对10亿条数据进行索引构建时，参数设置如下：</p><table><thead><tr><th>参数</th><th>设置</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td></tr><tr><td>Range1</td><td>start=0;end=5;size=4</td></tr><tr><td>Range2</td><td>start=6;end=9;size=2</td></tr><tr><td>Range3</td><td>start=10;end=16;size=4</td></tr><tr><td>FieldSize1</td><td>index=0;size=4</td></tr><tr><td>FieldSize2</td><td>index=1;size=8</td></tr><tr><td>FieldSize3</td><td>index=2;size=4</td></tr></tbody></table><p>那么，整个索引文件$Index_{sfz}$大小不会超过15GB：</p><ul><li>元数据大小：36 byte</li><li>一级索引大小至多：(6 + 12 * 32000) byte</li><li>二级索引大小至多：(6 + 10 * 100) * 32000 byte</li><li>内容大小：16 * 1000000000 byte</li></ul><h4 id="手机号码可索引文件"><a href="#手机号码可索引文件" class="headerlink" title="手机号码可索引文件"></a>手机号码可索引文件</h4><p>用于通过手机号码检索记录的场景。</p><h5 id="总体结构-1"><a href="#总体结构-1" class="headerlink" title="总体结构"></a>总体结构</h5><p>和身份证号码可索引文件的总体结构相同。</p><h5 id="元数据结构-1"><a href="#元数据结构-1" class="headerlink" title="元数据结构"></a>元数据结构</h5><p>和身份证号码可索引文件的元数据结构相同。</p><h5 id="一级索引结构-1"><a href="#一级索引结构-1" class="headerlink" title="一级索引结构"></a>一级索引结构</h5><p>和身份证号码可索引文件的一级索引结构相同。</p><h5 id="二级索引结构-1"><a href="#二级索引结构-1" class="headerlink" title="二级索引结构"></a>二级索引结构</h5><p>和身份证号码可索引文件的二级索引结构相同。</p><h5 id="内容结构-1"><a href="#内容结构-1" class="headerlink" title="内容结构"></a>内容结构</h5><img src="/a-index-for-data-query-design-and-implementation/手机号索引内容结构.png" title="手机号索引内容结构"><p>从左到右依次是：</p><ul><li><code>Range3</code>表示元数据中第三个Range描述由索引字段生成的值，每个值是唯一的</li><li><code>SFZ</code>表示一个身份证号码（其中校验位已去除）</li><li><code>Name Seq</code>表示姓名编号</li></ul><p>每个二级索引下的记录按照Range3值排序。</p><h5 id="索引文件构建-1"><a href="#索引文件构建-1" class="headerlink" title="索引文件构建"></a>索引文件构建</h5><p>索引构建时需要对原始数据做一定的处理。</p><ol><li>使用身份证索引构建过程中生成的姓名编码文件$Name_{code}$中的编码替换原始数据中的姓名，生成文件$MF_1$</li><li>对文件$MF_1$中的手机号码字段进行切分，按照一级索引、二级索引和内容前缀的顺序并使用”,”重新拼接，生成文件$MF_2$</li><li>对文件$MF2$中记录按照重新组合后的手机号码进行排序，生成文件$MF_3$</li><li>对文件$MF3$进行处理，生成最终的手机号码可索引文件$Index_{mob}$</li></ol><p>假设对10亿条数据进行索引构建时，参数设置如下：</p><table><thead><tr><th>参数</th><th>设置</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td></tr><tr><td>Range1</td><td>start=0;end=2;size=2</td></tr><tr><td>Range2</td><td>start=3;end=6;size=2</td></tr><tr><td>Range3</td><td>start=7;end=10;size=2</td></tr><tr><td>FieldSize1</td><td>index=0;size=2</td></tr><tr><td>FieldSize2</td><td>index=1;size=8</td></tr><tr><td>FieldSize3</td><td>index=2;size=4</td></tr></tbody></table><p>那么，整个索引文件$Index_{mob}$大小不超过13GB：</p><ul><li>元数据大小：36 byte</li><li>一级索引大小至多：(6 + 10 * 60) byte</li><li>二级索引大小至多：(6 + 10 * 10000) * 60 byte</li><li>内容大小：14 * 1000000000 byte</li></ul><h4 id="姓名字典文件"><a href="#姓名字典文件" class="headerlink" title="姓名字典文件"></a>姓名字典文件</h4><p>用于姓名编号到姓名的转换。该文件结构比较简单。</p><h5 id="总体结构-2"><a href="#总体结构-2" class="headerlink" title="总体结构"></a>总体结构</h5><img src="/a-index-for-data-query-design-and-implementation/姓名索引总体结构.png" title="姓名索引总体结构"><h5 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h5><img src="/a-index-for-data-query-design-and-implementation/姓名索引结构.png" title="姓名索引结构"><p>从左到右依次是：</p><ul><li><code>Len1</code>表示第一个姓名长度</li><li><code>Len2</code>表示第二个姓名长度</li><li><code>Len3</code>表示第三个姓名长度，以此类推</li><li><code>Length</code>表示整个二级索引（不包含Length所占用的4个字节）的长度</li></ul><p>可通过长度累加计算生成对应的姓名在文件中的位置。</p><h5 id="内容结构-2"><a href="#内容结构-2" class="headerlink" title="内容结构"></a>内容结构</h5><img src="/a-index-for-data-query-design-and-implementation/姓名内容结构.png" title="姓名内容结构"><p>其中内容的存储顺序和索引的存储顺序依次对应。</p><h5 id="索引文件构建-2"><a href="#索引文件构建-2" class="headerlink" title="索引文件构建"></a>索引文件构建</h5><p>在身份证号码可索引文件中已经生成文件$Name_{index}$ 。此索引文件的大小为取决于姓名去重后数量。</p><ul><li>索引大小：姓名去重后数量 * 1 byte</li><li>内容大小：3 * 姓名去重后总长度 byte</li></ul><h3 id="2-内存中的索引结构"><a href="#2-内存中的索引结构" class="headerlink" title="2. 内存中的索引结构"></a>2. 内存中的索引结构</h3><p>使用时，将身份证号码可索引文件和手机号码可索引文件中的索引部分全部加载到内存，姓名字典文件全部加载到内存中。</p><h4 id="身份证号码索引"><a href="#身份证号码索引" class="headerlink" title="身份证号码索引"></a>身份证号码索引</h4><h5 id="索引构建"><a href="#索引构建" class="headerlink" title="索引构建"></a>索引构建</h5><p>加载所有的一二级索引到内存中，构建散列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer, Long&gt;&gt; index;</span><br></pre></td></tr></table></figure><p>如果构建一二级索引时，使用身份证号码中的地址码作为一级索引，出生年份作为二级索引，那么整个索引个数不超过3840000个。</p><h5 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h5><p>可以通过如下步骤使用索引：</p><ol><li>使用Range1的start和end获取待查询身份证号码对应的一级索引值$Value_1$</li><li>通过索引值$Value_1$，查询索引Index，得到二级索引$Index_{2}$。如果无法找到，则不存在该身份证号码，进入第九步</li><li>使用Range2的start和end获取待查询身份证号码对应的二级索引值$Value_2$ </li><li>通过索引值$Value_2$，查询二级索引$Index_{2}$，得到记录在索引文件中的位置${Offset}$和对应的记录条数$Num$。如果无法找到，则不存在该身份证号码，进入第九步</li><li>使用Range3的start和end获取待查询身份证号码对应的记录前缀$Prefix$</li><li>通过位置${Offset}$读取索引文件中的记录，并比对记录中的前缀是否等于$Prefix$</li><li>如果相等，则继续读取下一条记录，直到找到的记录前缀不等于$Prefix$ ，返回获得的记录；如果不相等，继续读取下一条记录，直到找到的记录前缀等于$Prefix$ 或者$Num$为零（即无剩余记录）</li><li>如果获得记录数不为空，则构造查询结果。将查询使用的身份证号码反填到结果中，并使用姓名编号通过姓名字典获取对应的姓名。得到最终查询结果，并放回</li><li>结束本次查询</li></ol><h4 id="手机号码索引"><a href="#手机号码索引" class="headerlink" title="手机号码索引"></a>手机号码索引</h4><h5 id="索引构建-1"><a href="#索引构建-1" class="headerlink" title="索引构建"></a>索引构建</h5><p>加载所有的一二级索引到内存中，构建散列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer, Long&gt;&gt; index;</span><br></pre></td></tr></table></figure><p>如果构建一二级索引时，使用手机号码中的用户号码作为一级索引，网络识别码作为二级索引，那么整个索引个数不超过600000个。</p><h5 id="索引使用-1"><a href="#索引使用-1" class="headerlink" title="索引使用"></a>索引使用</h5><p>可以通过如下步骤使用索引：</p><ol><li>使用Range1的start和end获取待查询手机号码对应的一级索引值$Value_1$</li><li>通过索引值$Value_1$，查询索引Index，得到二级索引$Index_{2}$。如果无法找到，则不存在该手机号码，进入第九步</li><li>使用Range2的start和end获取待查询手机号码对应的二级索引值$Value_2$ </li><li>通过索引值$Value_2$，查询二级索引$Index_{2}$，得到记录在索引文件中的位置${Offset}$和对应的记录条数$Num$。如果无法找到，则不存在该手机号码，进入第九步</li><li>使用Range3的start和end获取待查询手机号码对应的记录前缀$Prefix$</li><li>通过位置${Offset}$读取索引文件中的记录，并比对记录中的前缀是否等于$Prefix$</li><li>如果相等，则继续读取下一条记录，直到找到的记录前缀不等于$Prefix$ ，返回获得的记录；如果不相等，继续读取下一条记录，直到找到的记录前缀等于$Prefix$ 或者$Num$为零（即无剩余记录）</li><li>如果获得记录数不为空，则构造查询结果。将查询使用的手机号码反填到结果中，计算并回填身份证号码因构建时去除的校验位，使用姓名编号通过姓名字典获取对应的姓名。得到最终查询结果，并返回</li><li>结束本次查询</li></ol><h4 id="姓名字典"><a href="#姓名字典" class="headerlink" title="姓名字典"></a>姓名字典</h4><h5 id="索引结构-1"><a href="#索引结构-1" class="headerlink" title="索引结构"></a>索引结构</h5><p>加载整个字典文件到内存中，并按照索引中的顺序给每个姓名依次赋予编号。这个索引可以使用以下数组表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] index = <span class="keyword">new</span> String[姓名个数];</span><br></pre></td></tr></table></figure><p>这个索引占用内存大小和姓名个数有关。</p><h5 id="索引使用-2"><a href="#索引使用-2" class="headerlink" title="索引使用"></a>索引使用</h5><p>通过身份证号码索引或者手机号码索引获取得到的记录中取得姓名编号$Seq$，直接通过<code>index[Seq]</code>得到相应的姓名。</p><h3 id="3-索引的选择问题"><a href="#3-索引的选择问题" class="headerlink" title="3. 索引的选择问题"></a>3. 索引的选择问题</h3><p>索引的选择对性能的影响主要在于数据的分布情况。如果一二级索引没有很好的”区分度“或者说一致性分布不佳，则会导致部分索引下的记录数据量过多，进而导致查询有大概率落入这些区域，造成更多的磁盘I/O和搜索时间。</p><p>同时，整个索引（包括一级索引和二级索引）的数量也要控制，否则会造成索引加载后，内存占用过高或者不能将索引全部加载到内存，导致索引效率下降。</p><h4 id="身份证号码索引选择"><a href="#身份证号码索引选择" class="headerlink" title="身份证号码索引选择"></a>身份证号码索引选择</h4><p>从身份证号码的组成来看，顺序码和出生月日的随机性和均匀性较好。因此，这里选择出生月日（身份证10位到14位）作为一级索引，顺序码（身份证15位到17位）作为二级索引。使用两千万真实身份证号码进行测试：</p><table><thead><tr><th>统计项</th><th>统计值</th></tr></thead><tbody><tr><td>一级索引数量</td><td>3650</td></tr><tr><td>二级索引数量</td><td>2988063</td></tr><tr><td>记录总数</td><td>26888239</td></tr><tr><td>记录最大数量</td><td>421</td></tr><tr><td>记录最小数量</td><td>1</td></tr><tr><td>记录平均数量</td><td>9</td></tr><tr><td>记录数量标准差</td><td>13.2</td></tr></tbody></table><p>整体散列效果还是可以的。这种索引理论上总共有3650000个。</p><p>现在有10亿条记录，每个二级索引下平均记录数为274条左右。每条记录大小为16byte，那么平均每个二级索引下的记录大小4KB左右，而每次I/O读取的一个磁盘页大小一般为4KB，这样每次平均只需要一次I/O就可以完成数据的搜索。</p><h4 id="手机号码索引选择"><a href="#手机号码索引选择" class="headerlink" title="手机号码索引选择"></a>手机号码索引选择</h4><p>从手机号码的组成来看，用户号码的随机性和均匀性较好。因此，这里选择用户号码（手机号码8位到11位）作为一级索引，网络识别码加一位网络识别码（手机号码1位到4位）作为二级索引。使用两千万真实手机号码进行测试：</p><table><thead><tr><th>统计项</th><th>统计值</th></tr></thead><tbody><tr><td>一级索引数量</td><td>10000</td></tr><tr><td>二级索引数量</td><td>2787015</td></tr><tr><td>记录总数</td><td>26888239</td></tr><tr><td>记录最大数量</td><td>4625</td></tr><tr><td>记录最小数量</td><td>1</td></tr><tr><td>记录平均数量</td><td>9.7</td></tr><tr><td>记录数量标准差</td><td>16.76</td></tr></tbody></table><p>整体散列效果还是可以的。这种索引理论上不超过6000000个。</p><p>现在有10亿条记录，每个二级索引下平均记录数为200条左右。每条记录大小为14byte，那么平均每个二级索引下的记录大小3KB左右，而每次I/O读取的一个磁盘页大小一般为4KB，这样每次平均只需要一次I/O就可以完成数据的搜索。</p><h2 id="三、关于缓存"><a href="#三、关于缓存" class="headerlink" title="三、关于缓存"></a>三、关于缓存</h2><p>虽然每次I/O很小，但随着访问量增大，I/O变得频繁。因此，可以使用缓存，减少磁盘I/O，提升性能。</p><h3 id="1-“免费的午餐”"><a href="#1-“免费的午餐”" class="headerlink" title="1. “免费的午餐”"></a>1. “免费的午餐”</h3><p>我们知道计算机在速度上是“阶级”分明的。CPU运行速度最快，内存存取速度跟不上，于是有了L1、L2甚至L3缓存。同样磁盘速度相对于内存而言，又是一个量级的差距，因此操作系统往往会充分利用系统中空闲的内存来作为磁盘读取和写入数据的缓存，来提高I/O性能。在Linux系统中，这部分工作通过PageCache和BufferCache来实现（2.4以后，统一使用PageCache实现），比如我们在系统中执行<code>free -m</code>命令时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:        257931     251719       6211          3        659     205733</span><br><span class="line">-/+ buffers/cache:      45326     212604 </span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure><p>其中的<code>cached</code>即读写文件时的缓存，包括页缓存和可回收Slab缓存，而<code>buffers</code>则为读写磁盘时的缓存（一般不大）。这里我们重点关注<code>cached</code> ，可以从<code>/proc/meminfo</code>中得到根据详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:         210684424 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:    7465988 kB</span><br></pre></td></tr></table></figure><p>下面我们看一下，这一机制对性能的影响。</p><p>首先，先清空系统缓存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br></pre></td></tr></table></figure><p>查看系统缓存情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:           121468 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      86560 kB</span><br></pre></td></tr></table></figure><p>读取索引文件（记录总数三千万不到），构建索引后，查看系统缓存情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:           291524 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      82520 kB</span><br></pre></td></tr></table></figure><p>可以看到页缓存明显增加，新增了大约166MB。</p><p>使用100000条数据模拟查询，查看系统缓存情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:           667220 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      82520 kB</span><br></pre></td></tr></table></figure><p>可以看出页缓存进一步增加，又新增了大约366MB。而此时，查询性能情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 3730 ms</span><br><span class="line">Avg time: 0.037300 ms</span><br><span class="line">Max time: 2 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>后续使用相同的数据重复两次查询，得到的性能情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">Total time: 429 ms</span><br><span class="line">Avg time: 0.004290 ms</span><br><span class="line">Max time: 1 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line">Total time: 423 ms</span><br><span class="line">Avg time: 0.004230 ms</span><br><span class="line">Max time: 12 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看出，页缓存对性能的提升很明显。</p><p>这部分内存由操作系统自动管理的（比如通过LRU策略进行缓存页淘汰）。当系统内存不足时，如果页缓存是“干净”的，则直接使用；否则，就需要先将“脏页”回写到磁盘后，才能使用，此时会产生磁盘I/O。这里，由于我们只是做记录查询，并不涉及到文件写入，因此索引文件占用的缓存，不会产生后续的磁盘I/O（或者flush操作），对系统影响较小。</p><h4 id="获取磁盘页大小"><a href="#获取磁盘页大小" class="headerlink" title="获取磁盘页大小"></a>获取磁盘页大小</h4><p>磁盘最小可访问单位称为sector（一般大小为512 bytes），而操作系统则以block为单位来实现块设备（比如磁盘）的I/O操作。对磁盘而言，block大小必须是sector的整数倍。</p><p>我们可以通过<code>blockdev</code>命令获取当前磁盘的block大小，比如我使用的这台机器的block大小为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo blockdev --getbsz /dev/sda1</span></span><br><span class="line">4096 #大小为4KB</span><br></pre></td></tr></table></figure><p>当我们以block大小的整数倍进行磁盘数据读取时，往往会达到比较好的I/O性能。</p><h3 id="2-应用缓存"><a href="#2-应用缓存" class="headerlink" title="2. 应用缓存"></a>2. 应用缓存</h3><p>这里不进行任何应用层面的缓存，先看看测试结果，避免过早优化。</p><h2 id="四、性能测试"><a href="#四、性能测试" class="headerlink" title="四、性能测试"></a>四、性能测试</h2><h3 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h3><ul><li>OS: CentOS Linux release 7.3</li><li>CPU: 16 cores</li><li>Memory: 32 GB</li><li>JVM: Java HotSpot(TM) 64-Bit Server VM 1.8.0_181</li><li>VM Page Size: 4096 bytes</li><li>Block Size: 4096 bytes</li><li>JVM Parameters: -Xms4g -Xmx4g -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=64m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/root/logs/index.hprof</li></ul><h3 id="2-测试数据"><a href="#2-测试数据" class="headerlink" title="2. 测试数据"></a>2. 测试数据</h3><h4 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h4><p><em>按照身份证号码和手机号码组成规则，随机生成记录。其中姓名随机从25000000个姓名中选取</em></p><ul><li>数据总量：1000000000</li><li>文本文件大小：39 GB</li></ul><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><h5 id="身份证号码可索引文件-1"><a href="#身份证号码可索引文件-1" class="headerlink" title="身份证号码可索引文件"></a>身份证号码可索引文件</h5><table><thead><tr><th>统计项</th><th>统计值</th></tr></thead><tbody><tr><td>文件大小</td><td>15 GB</td></tr><tr><td>一级索引数量</td><td>3650</td></tr><tr><td>二级索引数量</td><td>3650000</td></tr><tr><td>记录总数</td><td>1000000000</td></tr><tr><td>记录最大数量</td><td>360</td></tr><tr><td>记录最小数量</td><td>184</td></tr><tr><td>记录平均数量</td><td>274</td></tr><tr><td>记录数量标准差</td><td>16.55</td></tr></tbody></table><h5 id="手机号码可索引文件-1"><a href="#手机号码可索引文件-1" class="headerlink" title="手机号码可索引文件"></a>手机号码可索引文件</h5><table><thead><tr><th>统计项</th><th>统计值</th></tr></thead><tbody><tr><td>文件大小</td><td>14 GB</td></tr><tr><td>一级索引数量</td><td>10000</td></tr><tr><td>二级索引数量</td><td>4500000</td></tr><tr><td>记录总数</td><td>1000000000</td></tr><tr><td>记录最大数量</td><td>305</td></tr><tr><td>记录最小数量</td><td>152</td></tr><tr><td>记录平均数量</td><td>222</td></tr><tr><td>记录数量标准差</td><td>14.90</td></tr></tbody></table><h5 id="姓名索引文件"><a href="#姓名索引文件" class="headerlink" title="姓名索引文件"></a>姓名索引文件</h5><table><thead><tr><th>统计项</th><th>统计值</th></tr></thead><tbody><tr><td>文件大小</td><td>241 MB</td></tr><tr><td>索引个数</td><td>25000000</td></tr><tr><td>记录总数</td><td>25000000</td></tr></tbody></table><h3 id="3-测试用例"><a href="#3-测试用例" class="headerlink" title="3. 测试用例"></a>3. 测试用例</h3><p><em>进行下面每项测试之前，均会清空系统缓存。</em></p><h4 id="数据重复查询"><a href="#数据重复查询" class="headerlink" title="数据重复查询"></a>数据重复查询</h4><p>使用多份相同数据（每份100000条）查询，其中查询数据全部均在索引中。这种情况下，会有效利用系统缓存，后续查询性能较好（不会产生读磁盘的I/O），系统缓存占比稳定。</p><h4 id="不同数据查询"><a href="#不同数据查询" class="headerlink" title="不同数据查询"></a>不同数据查询</h4><p>使用多份不同数据（每份100000条）查询，其中查询数据全部均在索引中。这种情况下，系统缓存作用有限（后续查询每次都会产生读磁盘的I/O），每次查询性能基本一致，系统缓存占比上升。</p><h4 id="缺失数据查询"><a href="#缺失数据查询" class="headerlink" title="缺失数据查询"></a>缺失数据查询</h4><p>使用多份不同数据（每份100000条）查询，其中查询数据中存在部分（50%）不在索引中。这种情况下，有些查询不会产生I/O，有些则会需要遍历数据产生更多的I/O。</p><h4 id="混合查询"><a href="#混合查询" class="headerlink" title="混合查询"></a>混合查询</h4><p>使用多份随机抽取数据（每份100000条）进行查询，这些数据可能重复或者不在索引中。这种情况下，性能表现更接近实际使用情况。</p><h3 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4. 测试结果"></a>4. 测试结果</h3><p><em>以身份证号码查询为例。</em></p><h4 id="运行时间和缓存使用情况"><a href="#运行时间和缓存使用情况" class="headerlink" title="运行时间和缓存使用情况"></a>运行时间和缓存使用情况</h4><h5 id="数据重复查询结果"><a href="#数据重复查询结果" class="headerlink" title="数据重复查询结果"></a>数据重复查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 17465 ms</span><br><span class="line">Avg time: 0.174650 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">Total time: 1118 ms</span><br><span class="line">Avg time: 0.011180 ms</span><br><span class="line">Max time: 5 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">第三次查询</span></span><br><span class="line">Total time: 1060 ms</span><br><span class="line">Avg time: 0.010600 ms</span><br><span class="line">Max time: 10 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看出系统缓存对性能具有很大的提升。此时，系统缓存情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1586556 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      99764 kB</span><br></pre></td></tr></table></figure><h5 id="不同数据查询结果"><a href="#不同数据查询结果" class="headerlink" title="不同数据查询结果"></a>不同数据查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 17610 ms</span><br><span class="line">Avg time: 0.176100 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生两次minor gc</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1048576K-&gt;960K(640512K)] 2599747K-&gt;1552139K(3437056K), 0.0941071 secs] [Times: user=0.06 sys=0.54, real=0.09 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466880K-&gt;928K(931840K)] 2018059K-&gt;1552115K(3728384K), 0.0623918 secs] [Times: user=0.08 sys=0.26, real=0.06 secs]</span><br><span class="line"></span><br><span class="line">Total time: 18221 ms</span><br><span class="line">Avg time: 0.182210 ms</span><br><span class="line">Max time: 63 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生两次minor gc</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466848K-&gt;928K(931840K)] 2018035K-&gt;1552123K(3728384K), 0.0223861 secs] [Times: user=0.07 sys=0.43, real=0.02 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466848K-&gt;832K(931840K)] 2018043K-&gt;1552027K(3728384K), 0.0320038 secs] [Times: user=0.07 sys=0.53, real=0.03 secs]</span><br><span class="line"></span><br><span class="line">Total time: 17604 ms</span><br><span class="line">Avg time: 0.176040 ms</span><br><span class="line">Max time: 33 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看出不同数据查询时，系统缓存的作用就比较有限了，同时JVM的gc对查询响应造成了一定影响。此时，系统缓存情况（明显升高）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          4704748 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     105124 kB</span><br></pre></td></tr></table></figure><h5 id="缺失数据查询结果"><a href="#缺失数据查询结果" class="headerlink" title="缺失数据查询结果"></a>缺失数据查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 18243 ms</span><br><span class="line">Avg time: 0.182430 ms</span><br><span class="line">Max time: 4 ms</span><br><span class="line">Min time: 0 m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生两次minor gc</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1048576K-&gt;928K(640512K)] 2599747K-&gt;1552107K(3437056K), 0.0126270 secs] [Times: user=0.07 sys=0.17, real=0.02 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466848K-&gt;896K(931840K)] 2018027K-&gt;1552083K(3728384K), 0.0321966 secs] [Times: user=0.09 sys=0.43, real=0.04 secs]</span><br><span class="line"></span><br><span class="line">Total time: 18000 ms</span><br><span class="line">Avg time: 0.180000 ms</span><br><span class="line">Max time: 33 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生两次minor gc</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466816K-&gt;608K(931840K)] 2018003K-&gt;1551803K(3728384K), 0.0102723 secs] [Times: user=0.22 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466528K-&gt;896K(931840K)] 2017723K-&gt;1552091K(3728384K), 0.0699209 secs] [Times: user=0.05 sys=0.47, real=0.07 secs]</span><br><span class="line"></span><br><span class="line">Total time: 16955 ms</span><br><span class="line">Avg time: 0.169550 ms</span><br><span class="line">Max time: 71 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看出存在缺失时，系统性能并未得到提高，因为部分数据需要遍历完二级索引下所有内容，才能够确认是否存在。此时，系统缓存情况（由于存在需要遍历的情况，导致缓存略微升高）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          4804712 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     105060 kB</span><br></pre></td></tr></table></figure><h4 id="I-O使用情况"><a href="#I-O使用情况" class="headerlink" title="I/O使用情况"></a>I/O使用情况</h4><p>这里使用<code>pidstat</code>工具查看。</p><h5 id="数据重复查询结果-1"><a href="#数据重复查询结果-1" class="headerlink" title="数据重复查询结果"></a>数据重复查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">04:59:50 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">04:59:51 PM    130285      0.00      7.92      0.00  java</span><br><span class="line">04:59:52 PM    130285   8048.00     16.00      0.00  java</span><br><span class="line">04:59:53 PM    130285  43072.00      0.00      0.00  java</span><br><span class="line">04:59:54 PM    130285  49452.00      0.00      0.00  java</span><br><span class="line">04:59:55 PM    130285  50292.00      0.00      0.00  java</span><br><span class="line">04:59:56 PM    130285  51128.00      0.00      0.00  java</span><br><span class="line">04:59:57 PM    130285  52108.00      0.00      0.00  java</span><br><span class="line">04:59:58 PM    130285  53636.00      0.00      0.00  java</span><br><span class="line">04:59:59 PM    130285  53728.00      0.00      0.00  java</span><br><span class="line">05:00:00 PM    130285  53692.00      0.00      0.00  java</span><br><span class="line">05:00:01 PM    130285  55040.00      0.00      0.00  java</span><br><span class="line">05:00:02 PM    130285  57048.00      0.00      0.00  java</span><br><span class="line">05:00:03 PM    130285  58036.00      0.00      0.00  java</span><br><span class="line">05:00:04 PM    130285  60212.00      0.00      0.00  java</span><br><span class="line">05:00:05 PM    130285  63564.00      0.00      0.00  java</span><br><span class="line">05:00:06 PM    130285  56996.00      0.00      0.00  java</span><br><span class="line">05:00:07 PM    130285  61492.00      0.00      0.00  java</span><br><span class="line">05:00:08 PM    130285  63192.00      0.00      0.00  java</span><br><span class="line">05:00:09 PM    130285  62884.00      0.00      0.00  java</span><br><span class="line">05:00:10 PM    130285  67424.00      0.00      0.00  java</span><br><span class="line">05:00:11 PM    130285  64876.00      0.00      0.00  java</span><br><span class="line">05:00:12 PM    130285  10348.00      0.00      0.00  java</span><br><span class="line">05:00:13 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:00:14 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:00:15 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">Average:       130285  43833.19      0.96      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">05:01:00 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:01:01 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:02 PM    130285      0.00     12.00      0.00  java</span><br><span class="line">05:01:03 PM    130285      0.00      4.00      0.00  java</span><br><span class="line">05:01:04 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:05 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:06 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:07 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:08 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:09 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:10 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:11 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:12 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:13 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:14 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:15 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:16 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:17 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:18 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:19 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:20 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:21 PM    130285      0.00      8.00      0.00  java</span><br><span class="line">05:01:22 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:23 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:24 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:01:25 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">Average:       130285      0.00      0.96      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line">05:03:20 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:03:21 PM    130285      0.00      8.00      0.00  java</span><br><span class="line">05:03:22 PM    130285      0.00      4.00      0.00  java</span><br><span class="line">05:03:23 PM    130285      0.00     12.00      0.00  java</span><br><span class="line">05:03:24 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:25 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:26 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:27 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:28 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:29 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:30 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:31 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:32 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:33 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:34 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:35 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:36 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:37 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:38 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:39 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:40 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:41 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:42 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:43 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:44 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">05:03:45 PM    130285      0.00      0.00      0.00  java</span><br><span class="line">Average:       130285      0.00      0.96      0.00  java</span><br></pre></td></tr></table></figure><p>可以看出系统缓存对I/O的影响。</p><h5 id="不同数据查询结果-1"><a href="#不同数据查询结果-1" class="headerlink" title="不同数据查询结果"></a>不同数据查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">05:07:03 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:07:04 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:07:05 PM    130480   6560.00      0.00      0.00  java</span><br><span class="line">05:07:06 PM    130480  44812.00      0.00      0.00  java</span><br><span class="line">05:07:07 PM    130480  50796.00      0.00      0.00  java</span><br><span class="line">05:07:08 PM    130480  50912.00      0.00      0.00  java</span><br><span class="line">05:07:09 PM    130480  52296.00      0.00      0.00  java</span><br><span class="line">05:07:10 PM    130480  52388.00      0.00      0.00  java</span><br><span class="line">05:07:11 PM    130480  54704.00      0.00      0.00  java</span><br><span class="line">05:07:12 PM    130480  54504.00      0.00      0.00  java</span><br><span class="line">05:07:13 PM    130480  54952.00      0.00      0.00  java</span><br><span class="line">05:07:14 PM    130480  56172.00      0.00      0.00  java</span><br><span class="line">05:07:15 PM    130480  58564.00      0.00      0.00  java</span><br><span class="line">05:07:16 PM    130480  61392.00      8.00      0.00  java</span><br><span class="line">05:07:17 PM    130480  61380.00      8.00      0.00  java</span><br><span class="line">05:07:18 PM    130480  62504.00      0.00      0.00  java</span><br><span class="line">05:07:19 PM    130480  61820.00      0.00      0.00  java</span><br><span class="line">05:07:20 PM    130480  64320.00      0.00      0.00  java</span><br><span class="line">05:07:21 PM    130480  62772.00      0.00      0.00  java</span><br><span class="line">05:07:22 PM    130480  64944.00      0.00      0.00  java</span><br><span class="line">05:07:23 PM    130480  66764.00      0.00      0.00  java</span><br><span class="line">05:07:24 PM    130480  53240.00      4.00      0.00  java</span><br><span class="line">05:07:25 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:07:26 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:07:27 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:07:28 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">Average:       130480  43831.84      0.80      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">05:07:55 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:07:56 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:07:57 PM    130480  24824.00     16.00      0.00  java</span><br><span class="line">05:07:58 PM    130480  64304.00      0.00      0.00  java</span><br><span class="line">05:07:59 PM    130480  68604.00      0.00      0.00  java</span><br><span class="line">05:08:00 PM    130480  72124.00      0.00      0.00  java</span><br><span class="line">05:08:01 PM    130480  70976.00      0.00      0.00  java</span><br><span class="line">05:08:02 PM    130480  72056.00      0.00      0.00  java</span><br><span class="line">05:08:03 PM    130480  69000.00      0.00      0.00  java</span><br><span class="line">05:08:04 PM    130480  70408.00      0.00      0.00  java</span><br><span class="line">05:08:05 PM    130480  73116.00      0.00      0.00  java</span><br><span class="line">05:08:06 PM    130480  72160.00      0.00      0.00  java</span><br><span class="line">05:08:07 PM    130480  74628.00      0.00      0.00  java</span><br><span class="line">05:08:08 PM    130480  75816.00      0.00      0.00  java</span><br><span class="line">05:08:09 PM    130480  75796.00      0.00      0.00  java</span><br><span class="line">05:08:10 PM    130480  75312.00      0.00      0.00  java</span><br><span class="line">05:08:11 PM    130480  78968.00      0.00      0.00  java</span><br><span class="line">05:08:12 PM    130480  80120.00      0.00      0.00  java</span><br><span class="line">05:08:13 PM    130480  79496.00      0.00      0.00  java</span><br><span class="line">05:08:14 PM    130480  77220.00      0.00      0.00  java</span><br><span class="line">05:08:15 PM    130480  81280.00      0.00      0.00  java</span><br><span class="line">05:08:16 PM    130480  83493.07      0.00      0.00  java</span><br><span class="line">05:08:17 PM    130480  23280.00     16.00      0.00  java</span><br><span class="line">05:08:18 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:08:19 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:08:20 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">Average:       130480  58529.23      1.28      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line">05:08:39 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:08:40 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:08:41 PM    130480   1592.00      0.00      0.00  java</span><br><span class="line">05:08:42 PM    130480  84484.00      0.00      0.00  java</span><br><span class="line">05:08:43 PM    130480  82408.00      0.00      0.00  java</span><br><span class="line">05:08:44 PM    130480  81532.00      0.00      0.00  java</span><br><span class="line">05:08:45 PM    130480  81908.00      0.00      0.00  java</span><br><span class="line">05:08:46 PM    130480  86284.00      8.00      0.00  java</span><br><span class="line">05:08:47 PM    130480  82124.00      8.00      0.00  java</span><br><span class="line">05:08:48 PM    130480  84728.00      0.00      0.00  java</span><br><span class="line">05:08:49 PM    130480  85772.00      8.00      0.00  java</span><br><span class="line">05:08:50 PM    130480  86520.00      0.00      0.00  java</span><br><span class="line">05:08:51 PM    130480  88544.00      0.00      0.00  java</span><br><span class="line">05:08:52 PM    130480  89620.00      0.00      0.00  java</span><br><span class="line">05:08:53 PM    130480  88520.00      0.00      0.00  java</span><br><span class="line">05:08:54 PM    130480  89848.00      0.00      0.00  java</span><br><span class="line">05:08:55 PM    130480  90216.00      0.00      0.00  java</span><br><span class="line">05:08:56 PM    130480  91260.00      0.00      0.00  java</span><br><span class="line">05:08:57 PM    130480  91752.00      0.00      0.00  java</span><br><span class="line">05:08:58 PM    130480  90956.00      0.00      0.00  java</span><br><span class="line">05:08:59 PM    130480  90600.00      0.00      0.00  java</span><br><span class="line">05:09:00 PM    130480  86072.00      0.00      0.00  java</span><br><span class="line">05:09:01 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:09:02 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:09:03 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">05:09:04 PM    130480      0.00      0.00      0.00  java</span><br><span class="line">Average:       130480  66189.60      0.96      0.00  java</span><br></pre></td></tr></table></figure><p>可以看到整个查询过程中，产生了大量的读磁盘操作，此时系统缓存作用已失效。</p><h5 id="缺失数据查询结果-1"><a href="#缺失数据查询结果-1" class="headerlink" title="缺失数据查询结果"></a>缺失数据查询结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询时</span></span><br><span class="line">05:13:08 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:13:09 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:13:10 PM    130623  14756.00     16.00      0.00  java</span><br><span class="line">05:13:11 PM    130623  51836.00      4.00      0.00  java</span><br><span class="line">05:13:12 PM    130623  60256.00      0.00      0.00  java</span><br><span class="line">05:13:13 PM    130623  56628.00      0.00      0.00  java</span><br><span class="line">05:13:14 PM    130623  58560.00      0.00      0.00  java</span><br><span class="line">05:13:15 PM    130623  59576.00      0.00      0.00  java</span><br><span class="line">05:13:16 PM    130623  58652.00      0.00      0.00  java</span><br><span class="line">05:13:17 PM    130623  60588.00      0.00      0.00  java</span><br><span class="line">05:13:18 PM    130623  62436.00      0.00      0.00  java</span><br><span class="line">05:13:19 PM    130623  60796.00      0.00      0.00  java</span><br><span class="line">05:13:20 PM    130623  63520.00      0.00      0.00  java</span><br><span class="line">05:13:21 PM    130623  62196.00      0.00      0.00  java</span><br><span class="line">05:13:22 PM    130623  64756.00      0.00      0.00  java</span><br><span class="line">05:13:23 PM    130623  66768.00      0.00      0.00  java</span><br><span class="line">05:13:24 PM    130623  69020.00      0.00      0.00  java</span><br><span class="line">05:13:25 PM    130623  68440.00      0.00      0.00  java</span><br><span class="line">05:13:26 PM    130623  67936.00      0.00      0.00  java</span><br><span class="line">05:13:27 PM    130623  68668.00      8.00      0.00  java</span><br><span class="line">05:13:28 PM    130623  68524.00      0.00      0.00  java</span><br><span class="line">05:13:29 PM    130623  70744.00      0.00      0.00  java</span><br><span class="line">05:13:30 PM    130623  11944.00     12.00      0.00  java</span><br><span class="line">05:13:31 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:13:32 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:13:33 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">Average:       130623  49064.00      1.60      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询时</span></span><br><span class="line">05:14:06 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:14:07 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:14:08 PM    130623  14780.00     12.00      0.00  java</span><br><span class="line">05:14:09 PM    130623  73016.00      4.00      0.00  java</span><br><span class="line">05:14:10 PM    130623  70944.00      0.00      0.00  java</span><br><span class="line">05:14:11 PM    130623  74692.00      0.00      0.00  java</span><br><span class="line">05:14:12 PM    130623  73040.00      0.00      0.00  java</span><br><span class="line">05:14:13 PM    130623  71388.00      0.00      0.00  java</span><br><span class="line">05:14:14 PM    130623  74496.00      0.00      0.00  java</span><br><span class="line">05:14:15 PM    130623  75664.00      0.00      0.00  java</span><br><span class="line">05:14:16 PM    130623  74124.00      0.00      0.00  java</span><br><span class="line">05:14:17 PM    130623  78780.00      0.00      0.00  java</span><br><span class="line">05:14:18 PM    130623  80544.00      0.00      0.00  java</span><br><span class="line">05:14:19 PM    130623  80900.00      0.00      0.00  java</span><br><span class="line">05:14:20 PM    130623  79080.00      0.00      0.00  java</span><br><span class="line">05:14:21 PM    130623  81560.00      0.00      0.00  java</span><br><span class="line">05:14:22 PM    130623  80052.00      0.00      0.00  java</span><br><span class="line">05:14:23 PM    130623  82700.00      0.00      0.00  java</span><br><span class="line">05:14:24 PM    130623  81516.00      0.00      0.00  java</span><br><span class="line">05:14:25 PM    130623  79516.00      0.00      0.00  java</span><br><span class="line">05:14:26 PM    130623  80132.00      0.00      0.00  java</span><br><span class="line">05:14:27 PM    130623  76940.00     12.00      0.00  java</span><br><span class="line">05:14:28 PM    130623      0.00      4.00      0.00  java</span><br><span class="line">05:14:29 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:14:30 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:14:31 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">Average:       130623  59330.83      1.28      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询时</span></span><br><span class="line">05:15:24 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">05:15:25 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:15:26 PM    130623  11612.00      0.00      0.00  java</span><br><span class="line">05:15:27 PM    130623  83676.00     12.00      0.00  java</span><br><span class="line">05:15:28 PM    130623  85748.00      0.00      0.00  java</span><br><span class="line">05:15:29 PM    130623  86284.00      0.00      0.00  java</span><br><span class="line">05:15:30 PM    130623  85180.00      0.00      0.00  java</span><br><span class="line">05:15:31 PM    130623  87876.00      0.00      0.00  java</span><br><span class="line">05:15:32 PM    130623  88352.00      0.00      0.00  java</span><br><span class="line">05:15:33 PM    130623  84836.00     16.00      0.00  java</span><br><span class="line">05:15:34 PM    130623  86608.00      0.00      0.00  java</span><br><span class="line">05:15:35 PM    130623  88252.00      0.00      0.00  java</span><br><span class="line">05:15:36 PM    130623  85608.00      0.00      0.00  java</span><br><span class="line">05:15:37 PM    130623  89340.00      0.00      0.00  java</span><br><span class="line">05:15:38 PM    130623  90892.00      0.00      0.00  java</span><br><span class="line">05:15:39 PM    130623  89996.00      0.00      0.00  java</span><br><span class="line">05:15:40 PM    130623  88764.00      0.00      0.00  java</span><br><span class="line">05:15:41 PM    130623  95248.00      0.00      0.00  java</span><br><span class="line">05:15:42 PM    130623  92192.00      0.00      0.00  java</span><br><span class="line">05:15:43 PM    130623  93600.00      0.00      0.00  java</span><br><span class="line">05:15:44 PM    130623  84732.00      0.00      0.00  java</span><br><span class="line">05:15:45 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:15:46 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:15:47 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:15:48 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">05:15:49 PM    130623      0.00      0.00      0.00  java</span><br><span class="line">Average:       130623  63951.84      1.12      0.00  java</span><br></pre></td></tr></table></figure><p>可以看出相比非缺失数据查询，其产生的磁盘I/O，并未有出现明显的差异。说明缺失的情况下，并不一定减少磁盘的I/O。</p><h4 id="CPU使用情况"><a href="#CPU使用情况" class="headerlink" title="CPU使用情况"></a>CPU使用情况</h4><p>以不同数据查询为例, 这里使用<code>pidstat</code>命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">05:19:54 PM       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">05:19:55 PM    130864    0.00    0.00    0.00    0.00    33  java</span><br><span class="line">05:19:56 PM    130864   52.00   10.00    0.00   62.00    33  java</span><br><span class="line">05:19:57 PM    130864   71.00   12.00    0.00   83.00    33  java</span><br><span class="line">05:19:58 PM    130864   41.00    9.00    0.00   50.00    33  java</span><br><span class="line">05:19:59 PM    130864   16.00    9.00    0.00   25.00    33  java</span><br><span class="line">05:20:00 PM    130864   13.00    9.00    0.00   22.00    33  java</span><br><span class="line">05:20:01 PM    130864   12.00    9.00    0.00   21.00    33  java</span><br><span class="line">05:20:02 PM    130864   13.00    8.00    0.00   21.00    33  java</span><br><span class="line">05:20:03 PM    130864   12.00   10.00    0.00   22.00    33  java</span><br><span class="line">05:20:04 PM    130864   13.00    8.00    0.00   21.00    33  java</span><br><span class="line">05:20:05 PM    130864   12.00    9.00    0.00   21.00    33  java</span><br><span class="line">05:20:06 PM    130864   12.00   10.00    0.00   22.00    33  java</span><br><span class="line">05:20:07 PM    130864   12.00    9.00    0.00   21.00    33  java</span><br><span class="line">05:20:08 PM    130864   12.00   10.00    0.00   22.00    33  java</span><br><span class="line">05:20:09 PM    130864   11.00   10.00    0.00   21.00    33  java</span><br><span class="line">05:20:10 PM    130864   10.00   11.00    0.00   21.00    33  java</span><br><span class="line">05:20:11 PM    130864   11.00    9.00    0.00   20.00    33  java</span><br><span class="line">05:20:12 PM    130864    9.00   12.00    0.00   21.00    33  java</span><br><span class="line">05:20:13 PM    130864   11.00    9.00    0.00   20.00    33  java</span><br><span class="line">05:20:14 PM    130864   10.00   11.00    0.00   21.00    33  java</span><br><span class="line">05:20:15 PM    130864   11.00    9.00    0.00   20.00    33  java</span><br><span class="line">05:20:16 PM    130864   10.00    8.00    0.00   18.00    33  java</span><br><span class="line">05:20:17 PM    130864    0.00    0.00    0.00    0.00    33  java</span><br><span class="line">05:20:18 PM    130864    0.00    0.00    0.00    0.00    33  java</span><br><span class="line">05:20:19 PM    130864    0.00    0.00    0.00    0.00    33  java</span><br><span class="line">Average:       130864   14.96    8.04    0.00   23.00     -  java</span><br></pre></td></tr></table></figure><p>整个查询过程中，系统负载水平较为稳定。计算能力并未成为系统的性能瓶颈。</p><h4 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h4><h5 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h5><p>以不同数据查询为例, 这里使用<code>pidstat</code>命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">05:22:53 PM       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command</span><br><span class="line">05:22:54 PM    130864      0.00      0.00 9227292 3801256   1.44  java</span><br><span class="line">05:22:55 PM    130864   2216.00      0.00 9227292 3808828   1.44  java</span><br><span class="line">05:22:56 PM    130864   2874.00      0.00 9227292 3819616   1.45  java</span><br><span class="line">05:22:57 PM    130864    128.00      0.00 9227292 3819692   1.45  java</span><br><span class="line">05:22:58 PM    130864     42.00      0.00 9227292 3819692   1.45  java</span><br><span class="line">05:22:59 PM    130864  11456.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:00 PM    130864     50.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:01 PM    130864     17.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:02 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:03 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:04 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:05 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:06 PM    130864     13.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:07 PM    130864      5.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:08 PM    130864      1.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:09 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:10 PM    130864     27.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:11 PM    130864     19.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:12 PM    130864     21.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:13 PM    130864     21.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:14 PM    130864     20.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:15 PM    130864      9.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:16 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:17 PM    130864      0.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">05:23:18 PM    130864      2.00      0.00 9227292 3820340   1.45  java</span><br><span class="line">Average:       130864    676.84      0.00 9227292 3819035   1.45  java</span><br></pre></td></tr></table></figure><p>可以看出这个过程中的内存使用量较为平稳，没有出现大幅度地波动。</p><h5 id="JVM情况"><a href="#JVM情况" class="headerlink" title="JVM情况"></a>JVM情况</h5><p>以不同数据查询为例。整个查询（三次）过程中，共产生四次Minor GC。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1048576K-&gt;960K(640512K)] 2599747K-&gt;1552139K(3437056K), 0.0870845 secs] [Times: user=0.04 sys=0.44, real=0.08 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466880K-&gt;768K(931840K)] 2018059K-&gt;1551955K(3728384K), 0.0046564 secs] [Times: user=0.07 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466688K-&gt;864K(931840K)] 2017875K-&gt;1552059K(3728384K), 0.0057137 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 466784K-&gt;640K(931840K)] 2017979K-&gt;1551835K(3728384K), 0.0069967 secs] [Times: user=0.08 sys=0.02, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>这些Minor GC会对查询的响应造成一定的延迟。</p><p>堆使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 477102080 (455.0MB)</span><br><span class="line">   used     = 132110816 (125.99069213867188MB)</span><br><span class="line">   free     = 344991264 (329.0093078613281MB)</span><br><span class="line">   27.690262008499314% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 477102080 (455.0MB)</span><br><span class="line">   used     = 655360 (0.625MB)</span><br><span class="line">   free     = 476446720 (454.375MB)</span><br><span class="line">   0.13736263736263737% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 477102080 (455.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 477102080 (455.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 2863661056 (2731.0MB)</span><br><span class="line">   used     = 1588423816 (1514.838996887207MB)</span><br><span class="line">   free     = 1275237240 (1216.161003112793MB)</span><br><span class="line">   55.46828988968169% used</span><br><span class="line"></span><br><span class="line">1390 interned Strings occupying 98760 bytes.</span><br></pre></td></tr></table></figure><p>由于整个程序的特点（启动时加载全部的索引和姓名），老生代（大约1.5 GB）是整个程序占用内存最大部分，其中包含了25000000个姓名和全部的一二级索引。这里我们每次在内存中构建完索引后，可以主动调用一下<code>System.gc()</code> ，清空构建过程中产生的大量可回收对象。避免后续查询时频繁地触发GC（特别是Full GC）。</p><h4 id="混合查询结果"><a href="#混合查询结果" class="headerlink" title="混合查询结果"></a>混合查询结果</h4><h5 id="身份证号码查询"><a href="#身份证号码查询" class="headerlink" title="身份证号码查询"></a>身份证号码查询</h5><p>共300000条记录，分三次查询。其中大约四分之一数据重复，一半数据不在索引中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 17822 ms</span><br><span class="line">Avg time: 0.178220 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">Total time: 12577 ms</span><br><span class="line">Avg time: 0.125770 ms</span><br><span class="line">Max time: 19 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line">Total time: 8846 ms</span><br><span class="line">Avg time: 0.088460 ms</span><br><span class="line">Max time: 5 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看到这种情况下系统缓存对性能还是具有一定的提升作用。第二次查询，由于发生两次Minor GC导致最大响应时间增高。</p><h5 id="手机号码查询"><a href="#手机号码查询" class="headerlink" title="手机号码查询"></a>手机号码查询</h5><p>共300000条记录，分三次查询。其中大约六分之一数据重复，一半数据不在索引中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次查询</span></span><br><span class="line">Total time: 15896 ms</span><br><span class="line">Avg time: 0.158960 ms</span><br><span class="line">Max time: 14 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次查询</span></span><br><span class="line">Total time: 13391 ms</span><br><span class="line">Avg time: 0.133910 ms</span><br><span class="line">Max time: 24 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三次查询</span></span><br><span class="line">Total time: 11262 ms</span><br><span class="line">Avg time: 0.112620 ms</span><br><span class="line">Max time: 29 ms</span><br><span class="line">Min time: 0 ms</span><br></pre></td></tr></table></figure><p>可以看到这种情况下系统缓存对性能还是具有一定的提升作用。第二三次查询，由于各发生两次Minor GC导致最大响应时间增高。</p><h2 id="五、改进"><a href="#五、改进" class="headerlink" title="五、改进"></a>五、改进</h2><h3 id="1-性能问题在哪里"><a href="#1-性能问题在哪里" class="headerlink" title="1. 性能问题在哪里"></a>1. 性能问题在哪里</h3><p>从测试结果来看，目前的性能已接近万级qps。但我们也发现，在缺失数据查询场景中，无论是执行时间还是磁盘I/O都没有明显变化，那是否是由于部分缺失数据需要遍历完二级索引下所有内容引起的呢？同时，也可以发现无论是否存在，每次都需要遍历二级索引进行线性搜索，能否避免呢或者降低搜索时间复杂度？</p><h3 id="2-问题验证"><a href="#2-问题验证" class="headerlink" title="2. 问题验证"></a>2. 问题验证</h3><h4 id="缺失数据遍历数据问题"><a href="#缺失数据遍历数据问题" class="headerlink" title="缺失数据遍历数据问题"></a>缺失数据遍历数据问题</h4><p>将缺失数据查询所用的数据，拆分为两组。一组完全在索引中（100000条），一组完全不在索引中（100000条）。进行两次独立测试，每次测试前情况系统缓存。这里以身份证号码查询为例：</p><h5 id="完全在索引中"><a href="#完全在索引中" class="headerlink" title="完全在索引中"></a>完全在索引中</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 17682 ms</span><br><span class="line">Avg time: 0.176820 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">10:25:01 AM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">10:25:02 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">10:25:03 AM      3003  22144.00     16.00      0.00  java</span><br><span class="line">10:25:04 AM      3003  50736.00      0.00      0.00  java</span><br><span class="line">10:25:05 AM      3003  52044.00      0.00      0.00  java</span><br><span class="line">10:25:06 AM      3003  54080.00      0.00      0.00  java</span><br><span class="line">10:25:07 AM      3003  54608.00      0.00      0.00  java</span><br><span class="line">10:25:08 AM      3003  57152.00      0.00      0.00  java</span><br><span class="line">10:25:09 AM      3003  57556.00      0.00      0.00  java</span><br><span class="line">10:25:10 AM      3003  58092.00      8.00      0.00  java</span><br><span class="line">10:25:11 AM      3003  59168.00      0.00      0.00  java</span><br><span class="line">10:25:12 AM      3003  61504.00      0.00      0.00  java</span><br><span class="line">10:25:13 AM      3003  63504.00      8.00      0.00  java</span><br><span class="line">10:25:14 AM      3003  64176.00      0.00      0.00  java</span><br><span class="line">10:25:15 AM      3003  65352.00      0.00      0.00  java</span><br><span class="line">10:25:16 AM      3003  64480.00      0.00      0.00  java</span><br><span class="line">10:25:17 AM      3003  66592.00      0.00      0.00  java</span><br><span class="line">10:25:18 AM      3003  66276.00      0.00      0.00  java</span><br><span class="line">10:25:19 AM      3003  67908.00      0.00      0.00  java</span><br><span class="line">10:25:20 AM      3003  68532.00      0.00      0.00  java</span><br><span class="line">10:25:21 AM      3003  40052.00      4.00      0.00  java</span><br><span class="line">10:25:22 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">10:25:23 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">10:25:24 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">10:25:25 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">10:25:26 AM      3003      0.00      0.00      0.00  java</span><br><span class="line">Average:         3003  43758.24      1.44      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1616060 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     102020 kB</span><br></pre></td></tr></table></figure><h5 id="完全不在索引中"><a href="#完全不在索引中" class="headerlink" title="完全不在索引中"></a>完全不在索引中</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 19666 ms</span><br><span class="line">Avg time: 0.196660 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">10:56:34 AM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">10:56:35 AM      3808      0.00      0.00      0.00  java</span><br><span class="line">10:56:36 AM      3808  15660.00     20.00      0.00  java</span><br><span class="line">10:56:37 AM      3808  58608.00      0.00      0.00  java</span><br><span class="line">10:56:38 AM      3808  64164.00      0.00      0.00  java</span><br><span class="line">10:56:39 AM      3808  62640.00      0.00      0.00  java</span><br><span class="line">10:56:40 AM      3808  65272.00      0.00      0.00  java</span><br><span class="line">10:56:41 AM      3808  64512.00      0.00      0.00  java</span><br><span class="line">10:56:42 AM      3808  66060.00      0.00      0.00  java</span><br><span class="line">10:56:43 AM      3808  62556.00      0.00      0.00  java</span><br><span class="line">10:56:44 AM      3808  65788.00      0.00      0.00  java</span><br><span class="line">10:56:45 AM      3808  63308.00      0.00      0.00  java</span><br><span class="line">10:56:46 AM      3808  61720.00      0.00      0.00  java</span><br><span class="line">10:56:47 AM      3808  67920.00      0.00      0.00  java</span><br><span class="line">10:56:48 AM      3808  67028.00      0.00      0.00  java</span><br><span class="line">10:56:49 AM      3808  69164.00      0.00      0.00  java</span><br><span class="line">10:56:50 AM      3808  70332.00      0.00      0.00  java</span><br><span class="line">10:56:51 AM      3808  70528.00      0.00      0.00  java</span><br><span class="line">10:56:52 AM      3808  70580.00      0.00      0.00  java</span><br><span class="line">10:56:53 AM      3808  70896.00      0.00      0.00  java</span><br><span class="line">10:56:54 AM      3808  71904.00      0.00      0.00  java</span><br><span class="line">10:56:55 AM      3808  74636.00      0.00      0.00  java</span><br><span class="line">10:56:56 AM      3808  54936.00      0.00      0.00  java</span><br><span class="line">10:56:57 AM      3808      0.00      0.00      0.00  java</span><br><span class="line">10:56:58 AM      3808      0.00      0.00      0.00  java</span><br><span class="line">10:56:59 AM      3808      0.00      0.00      0.00  java</span><br><span class="line">Average:         3808  53507.08      0.80      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1861960 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      99268 kB</span><br></pre></td></tr></table></figure><h5 id="验证结论"><a href="#验证结论" class="headerlink" title="验证结论"></a>验证结论</h5><p>可以看到缺失数据确实造成了更多磁盘I/O和更长的运行时间。其实，从身份证号码索引选择上也能够说明这点，出生月日和顺序码虽然能够得到较好的散列，但对身份证号码的唯一性识别能力较弱。</p><h4 id="内容遍历问题"><a href="#内容遍历问题" class="headerlink" title="内容遍历问题"></a>内容遍历问题</h4><p>构造两份数据（每份100000条），一份数据分布在二级索引下内容中处于靠前部分，另一份数据分布在二级索引下内容中处于靠后部分。这样靠前部分数据需要的遍历时间更少，而靠后部分数据则需要更多时间。</p><h5 id="靠前部分"><a href="#靠前部分" class="headerlink" title="靠前部分"></a>靠前部分</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 16815 ms</span><br><span class="line">Avg time: 0.168150 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">04:03:22 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">04:03:23 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:24 PM      6833  21072.00     16.00      0.00  java</span><br><span class="line">04:03:25 PM      6833  52096.00     24.00      0.00  java</span><br><span class="line">04:03:26 PM      6833  55812.00      0.00      0.00  java</span><br><span class="line">04:03:27 PM      6833  57224.00      0.00      0.00  java</span><br><span class="line">04:03:28 PM      6833  57376.00      0.00      0.00  java</span><br><span class="line">04:03:29 PM      6833  59780.00      0.00      0.00  java</span><br><span class="line">04:03:30 PM      6833  60488.00      0.00      0.00  java</span><br><span class="line">04:03:31 PM      6833  61204.00      0.00      0.00  java</span><br><span class="line">04:03:32 PM      6833  60820.00      0.00      0.00  java</span><br><span class="line">04:03:33 PM      6833  62728.00      0.00      0.00  java</span><br><span class="line">04:03:34 PM      6833  66012.00      0.00      0.00  java</span><br><span class="line">04:03:35 PM      6833  67892.00      0.00      0.00  java</span><br><span class="line">04:03:36 PM      6833  67268.00      0.00      0.00  java</span><br><span class="line">04:03:37 PM      6833  69724.00      0.00      0.00  java</span><br><span class="line">04:03:38 PM      6833  67656.00      0.00      0.00  java</span><br><span class="line">04:03:39 PM      6833  69760.00      0.00      0.00  java</span><br><span class="line">04:03:40 PM      6833  71436.00      0.00      0.00  java</span><br><span class="line">04:03:41 PM      6833  53516.00      0.00      0.00  java</span><br><span class="line">04:03:42 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:43 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:44 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:45 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:46 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">04:03:47 PM      6833      0.00      0.00      0.00  java</span><br><span class="line">Average:         6833  43274.56      1.60      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1602380 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     102388 kB</span><br></pre></td></tr></table></figure><h5 id="靠后部分"><a href="#靠后部分" class="headerlink" title="靠后部分"></a>靠后部分</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 19347 ms</span><br><span class="line">Avg time: 0.193470 ms</span><br><span class="line">Max time: 3 ms</span><br><span class="line">Min time: 0 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">04:06:04 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">04:06:05 PM      6983      0.00      0.00      0.00  java</span><br><span class="line">04:06:06 PM      6983    628.00      4.00      0.00  java</span><br><span class="line">04:06:07 PM      6983  40944.00      0.00      0.00  java</span><br><span class="line">04:06:08 PM      6983  48680.00      0.00      0.00  java</span><br><span class="line">04:06:09 PM      6983  48752.00      0.00      0.00  java</span><br><span class="line">04:06:10 PM      6983  49624.00      0.00      0.00  java</span><br><span class="line">04:06:11 PM      6983  50756.00      0.00      0.00  java</span><br><span class="line">04:06:12 PM      6983  51796.00      0.00      0.00  java</span><br><span class="line">04:06:13 PM      6983  52288.00      0.00      0.00  java</span><br><span class="line">04:06:14 PM      6983  53596.00      0.00      0.00  java</span><br><span class="line">04:06:15 PM      6983  54880.00      0.00      0.00  java</span><br><span class="line">04:06:16 PM      6983  56328.00      0.00      0.00  java</span><br><span class="line">04:06:17 PM      6983  54424.00      0.00      0.00  java</span><br><span class="line">04:06:18 PM      6983  55652.00      0.00      0.00  java</span><br><span class="line">04:06:19 PM      6983  58164.00      0.00      0.00  java</span><br><span class="line">04:06:20 PM      6983  60672.00      8.00      0.00  java</span><br><span class="line">04:06:21 PM      6983  60712.00      0.00      0.00  java</span><br><span class="line">04:06:22 PM      6983  58704.00      0.00      0.00  java</span><br><span class="line">04:06:23 PM      6983  61080.00      0.00      0.00  java</span><br><span class="line">04:06:24 PM      6983  61832.00      0.00      0.00  java</span><br><span class="line">04:06:25 PM      6983  63476.00      0.00      0.00  java</span><br><span class="line">04:06:26 PM      6983  49176.00     12.00      0.00  java</span><br><span class="line">04:06:27 PM      6983      0.00      0.00      0.00  java</span><br><span class="line">04:06:28 PM      6983      0.00      0.00      0.00  java</span><br><span class="line">04:06:29 PM      6983      0.00      0.00      0.00  java</span><br><span class="line">Average:         6983  43686.56      0.96      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1615152 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     101716 kB</span><br></pre></td></tr></table></figure><h5 id="验证结论-1"><a href="#验证结论-1" class="headerlink" title="验证结论"></a>验证结论</h5><p>记录位置的不同确实会造成运行时间变长（增加了2.5s），但由于每次磁盘I/O的单位是4KB，而一个二级索引下全部内容大小平均不超过4KB，因此在磁盘I/O上两者差别不大。</p><h3 id="3-改进方案"><a href="#3-改进方案" class="headerlink" title="3. 改进方案"></a>3. 改进方案</h3><h4 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h4><p>主要解决数据不在索引中引起的数据遍历问题，降低磁盘I/O和搜索时间。</p><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p>构造一个BloomFilter内容文件。内存中构建索引时，同时根据文件中的内容反序列化出BloomFilter。在读取磁盘上的数据之前增加BloomFilter过滤步骤。即每次查询通过索引获取访问位置后，首先通过BloomFilter验证记录是否可能存在。通过验证后，再通过访问位置读取磁盘数据，进行后续搜索。此处BloomFilter使用Guava实现。</p><h5 id="空间代价评估"><a href="#空间代价评估" class="headerlink" title="空间代价评估"></a>空间代价评估</h5><p>这里构造BloomFilter时设置放入全部十亿条身份证号码或者手机号码，并且设置期望的false positive（即不存在但被误判为存在）概率不高于1%。</p><p>此时整个BloomFilter序列化后，文件大小为<strong>1.2</strong> GB。加载入内存需要消耗时间，且内存使用量增高。</p><h5 id="时间代价评估"><a href="#时间代价评估" class="headerlink" title="时间代价评估"></a>时间代价评估</h5><p>设查询时身份证号码或者手机号码不在索引中的概率为$P_{miss}$ ，每次通过BloomFilter过滤执行时间为$T_f$，而过滤误判的概率为$P_{error}$ 。查询记录不在索引中时，读取磁盘进行搜索的平均时间为$T_{s}$ms。则在系统在使用BloomFilter前后的代价分别为：<br>$$<br>\begin{cases} Lost(before) = P_{miss} \times T_s \\ Lost(after) = T_f + P_{miss} \times P_{error} \times T_s \end{cases}<br>$$<br>即当以下不等式成立时，BloomFilter的使用能够提高系统性能。<br>$$<br>Lost(before) - Lost(after) = P_{miss} \times T_s \times (1 - P_{error}) &gt; T_f<br>$$<br>考虑十亿条记录中每个身份证号码或者手机号码都是唯一的极端情况下，且业务查询每个身份证号码或者手机号码是随机的。那么：</p><ul><li>身份证号码的$P_{miss} \ge 0.29$</li><li>手机号码的$P_{miss} \ge 0.78$</li></ul><p>这里我们设置误判概率$P_{error} \le 0.01$，则<br>$$<br>T_f &lt; 0.29 \times T_s \ge 0.06 \quad ms<br>$$<br>此时，BloomFilter的使用能够提高系统性能。</p><p>这里使用100000条（身份证号码）混合查询数据（其中50067条数据存在于索引中）进行测试，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passed = 50549</span><br><span class="line">denied = 49451</span><br><span class="line"></span><br><span class="line">Total time: 155.921255 ms</span><br><span class="line">Avg time: 0.001559 ms</span><br><span class="line">Max time: 16.535327 ms</span><br><span class="line">Min time: 0.000393 ms</span><br></pre></td></tr></table></figure><p>其中有482条误判。执行时间满足要求，即使用BloomFilter可以提高系统性能。</p><h4 id="内容前缀缓存"><a href="#内容前缀缓存" class="headerlink" title="内容前缀缓存"></a>内容前缀缓存</h4><h5 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h5><p>缓存每个二级索引中开始（最小）、中间和结束（最大）的内容前缀。查询时，通过比较待查询的内容前缀是否小于开始前缀或者大于结束内容前缀，来快速判断待查询的内容前缀是否存在。如果待查询的内容前缀存在，则比较其与中间前缀的大小。如果大于中间前缀，说明位于内容后半段，则直接读取后半段内容进行搜索；否则读取前半段内容进行搜索。这样减少了内容前缀位于后半段时的搜索时间（平均降低50%）。</p><p>缓存采用热启动的方式，即在读取一二级索引时，生成缓存。为了降低启动加载时间，构建索引文件时，在二级索引中增加以下相关内容：</p><img src="/a-index-for-data-query-design-and-implementation/身份证二级索引结构2.png" title="身份证二级索引改进后的结构"><ul><li><code>MinKey</code>表示该二级索引下最小内容前缀（即第一条）</li><li><code>MidKey</code>表示该二级索引下中间内容前缀</li><li><code>MaxKey</code>表示该二级索引下最大内容前缀（可能是最后一条，如果最大前缀只有一条的话）</li><li><code>MidDelta</code>表示中间内容前缀和第一条之间相差几条记录，可用于生成中间内容前缀所在位置</li><li><code>MaxDelta</code>表示最大内容前缀和第一条之间相差几条记录，可用于生成最大内容前缀所在位置</li></ul><h5 id="空间代价评估-1"><a href="#空间代价评估-1" class="headerlink" title="空间代价评估"></a>空间代价评估</h5><table><thead><tr><th>索引类型</th><th>空间代价</th></tr></thead><tbody><tr><td>身份证号码索引</td><td>二级索引个数 * (内容前缀长度  * 3 + 4) = 56 MB</td></tr><tr><td>手机号码索引</td><td>二级索引个数 * (内容前缀长度  * 3 + 4) = 43 MB</td></tr></tbody></table><h5 id="时间代价评估-1"><a href="#时间代价评估-1" class="headerlink" title="时间代价评估"></a>时间代价评估</h5><p>设查询时身份证号码或者手机号码不在索引中的概率为$P_{miss}$ ，每次通过缓存判断时间为$T_j$，而通过缓存判断依然不再记录中的概率为$P_{error}$ 。查询记录不在索引中时，读取磁盘进行搜索的平均时间为$T_{s}$ms。查询记录在索引中时，未使用缓存时，读取磁盘进行搜索的平均时间为$T_m$ ms。而使用缓存判断后，读取磁盘进行搜索的平均时间为$\alpha T_m$ ms。则在系统在使用缓存前后的代价分别为：<br>$$<br>\begin{cases} Lost(before) = P_{miss} \times T_s + (1-P_{miss}) \times T_m \\ Lost(after) = T_j + (1 - P_{miss}) \times \alpha T_m + P_{error} \times T_s\end{cases}<br>$$<br>即当以下不等式成立时，缓存的使用能够提高系统性能。<br>$$<br>Lost(before) - Lost(after) =  T_m  (1 - P_{miss})  (1 - \alpha) &gt; T_j - T_s(P_{error} - P_{miss})<br>$$<br>并且存在以下约束条件 ：<br>$$<br>\begin{cases} T_j &lt;&lt;  T_s \\ 0 \le P_{miss} \le 1 \\ 0 \lt \alpha \le 1 \end{cases}<br>$$<br>因此，性能一定能够得到提升，但提升多少，还是主要看使用缓存后，$P_{error}$和读取磁盘进行搜索的平均时间情况。</p><h3 id="4-改进效果"><a href="#4-改进效果" class="headerlink" title="4. 改进效果"></a>4. 改进效果</h3><p><em>这里以身份证号码查询为例</em></p><h4 id="使用Bloom-Filter后的测试结果"><a href="#使用Bloom-Filter后的测试结果" class="headerlink" title="使用Bloom Filter后的测试结果"></a>使用Bloom Filter后的测试结果</h4><p>使用Bloom Filter后，程序使用内存量相比之前多出了1GB左右。典型的时间换空间。</p><h5 id="完全在索引中数据查询"><a href="#完全在索引中数据查询" class="headerlink" title="完全在索引中数据查询"></a>完全在索引中数据查询</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 17908.957785 ms</span><br><span class="line">Avg time: 0.179090 ms</span><br><span class="line">Max time: 15.298127 ms</span><br><span class="line">Min time: 0.009509 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">02:16:29 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">02:16:30 PM     36203      0.00      0.00      0.00  java</span><br><span class="line">02:16:31 PM     36203      0.00      0.00      0.00  java</span><br><span class="line">02:16:32 PM     36203  23732.00     16.00      0.00  java</span><br><span class="line">02:16:33 PM     36203  49884.00      0.00      0.00  java</span><br><span class="line">02:16:34 PM     36203  51668.00      0.00      0.00  java</span><br><span class="line">02:16:35 PM     36203  53612.00      0.00      0.00  java</span><br><span class="line">02:16:36 PM     36203  53720.00      0.00      0.00  java</span><br><span class="line">02:16:37 PM     36203  56368.00      0.00      0.00  java</span><br><span class="line">02:16:38 PM     36203  56192.00      0.00      0.00  java</span><br><span class="line">02:16:39 PM     36203  57924.00      0.00      0.00  java</span><br><span class="line">02:16:40 PM     36203  58616.00      0.00      0.00  java</span><br><span class="line">02:16:41 PM     36203  60624.00      0.00      0.00  java</span><br><span class="line">02:16:42 PM     36203  62588.00      0.00      0.00  java</span><br><span class="line">02:16:43 PM     36203  63588.00      0.00      0.00  java</span><br><span class="line">02:16:44 PM     36203  64836.00      0.00      0.00  java</span><br><span class="line">02:16:45 PM     36203  63692.00      0.00      0.00  java</span><br><span class="line">02:16:46 PM     36203  66376.00      0.00      0.00  java</span><br><span class="line">02:16:47 PM     36203  65316.00      0.00      0.00  java</span><br><span class="line">02:16:48 PM     36203  67832.00      0.00      0.00  java</span><br><span class="line">02:16:49 PM     36203  67904.00      0.00      0.00  java</span><br><span class="line">02:16:50 PM     36203  51464.00      8.00      0.00  java</span><br><span class="line">02:16:51 PM     36203      0.00      4.00      0.00  java</span><br><span class="line">02:16:52 PM     36203      0.00      0.00      0.00  java</span><br><span class="line">02:16:53 PM     36203      0.00      0.00      0.00  java</span><br><span class="line">02:16:54 PM     36203      0.00      0.00      0.00  java</span><br><span class="line">Average:        36203  43837.44      1.12      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          2789188 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     106168 kB</span><br></pre></td></tr></table></figure><p>与之前相比，无明显差别。</p><h5 id="完全不在索引中数据查询"><a href="#完全不在索引中数据查询" class="headerlink" title="完全不在索引中数据查询"></a>完全不在索引中数据查询</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 432.726604 ms</span><br><span class="line">Avg time: 0.004327 ms</span><br><span class="line">Max time: 12.856279 ms</span><br><span class="line">Min time: 0.000800 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">02:33:18 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">02:33:19 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:20 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:21 PM     36473  14948.00     16.00      0.00  java</span><br><span class="line">02:33:22 PM     36473    464.00      0.00      0.00  java</span><br><span class="line">02:33:23 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:24 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:25 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:26 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:27 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:28 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:29 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:30 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:31 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:32 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:33 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:34 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:35 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:36 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:37 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:38 PM     36473      0.00      8.00      0.00  java</span><br><span class="line">02:33:39 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:40 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:41 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:42 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">02:33:43 PM     36473      0.00      0.00      0.00  java</span><br><span class="line">Average:        36473    616.48      0.96      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1713868 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      82000 kB</span><br></pre></td></tr></table></figure><p>与之前相比，无论是运行时间、磁盘I/O还是系统缓存都有了很大的提升。</p><h5 id="混合查询-1"><a href="#混合查询-1" class="headerlink" title="混合查询"></a>混合查询</h5><p>使用混合查询用例中的测试数据（100000条）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 10221.723065 ms</span><br><span class="line">Avg time: 0.102217 ms</span><br><span class="line">Max time: 13.377899 ms</span><br><span class="line">Min time: 0.001182 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">02:41:46 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">02:41:47 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:41:48 PM     36656   8480.00     24.00      0.00  java</span><br><span class="line">02:41:49 PM     36656  43936.00      0.00      0.00  java</span><br><span class="line">02:41:50 PM     36656  44032.00      0.00      0.00  java</span><br><span class="line">02:41:51 PM     36656  45076.00      0.00      0.00  java</span><br><span class="line">02:41:52 PM     36656  46752.00      0.00      0.00  java</span><br><span class="line">02:41:53 PM     36656  47796.00      0.00      0.00  java</span><br><span class="line">02:41:54 PM     36656  47348.00      0.00      0.00  java</span><br><span class="line">02:41:55 PM     36656  49084.00      0.00      0.00  java</span><br><span class="line">02:41:56 PM     36656  50328.00      0.00      0.00  java</span><br><span class="line">02:41:57 PM     36656  50908.00      0.00      0.00  java</span><br><span class="line">02:41:58 PM     36656  50520.00      0.00      0.00  java</span><br><span class="line">02:41:59 PM     36656  14832.00      0.00      0.00  java</span><br><span class="line">02:42:00 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:01 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:02 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:03 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:04 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:05 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:06 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:07 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:08 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:09 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:10 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">02:42:11 PM     36656      0.00      0.00      0.00  java</span><br><span class="line">Average:        36656  19963.68      0.96      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          2187460 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      97808 kB</span><br></pre></td></tr></table></figure><p>与之前相比，运行时间有了显著的提升。</p><h5 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h5><p>BloomFilter的使用确实能够明显地提升查询性能（不论是查询时间，还是磁盘I/O）。</p><h4 id="使用内容前缀缓存后的测试结果"><a href="#使用内容前缀缓存后的测试结果" class="headerlink" title="使用内容前缀缓存后的测试结果"></a>使用内容前缀缓存后的测试结果</h4><h5 id="靠前部分数据查询"><a href="#靠前部分数据查询" class="headerlink" title="靠前部分数据查询"></a>靠前部分数据查询</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 16982.256299 ms</span><br><span class="line">Avg time: 0.169823 ms</span><br><span class="line">Max time: 47.892767 ms</span><br><span class="line">Min time: 0.006427 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">02:55:07 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">02:55:08 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:09 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:10 PM     36882  44720.00      4.00      0.00  java</span><br><span class="line">02:55:11 PM     36882  53808.00      0.00      0.00  java</span><br><span class="line">02:55:12 PM     36882  56392.00      0.00      0.00  java</span><br><span class="line">02:55:13 PM     36882  57428.00      0.00      0.00  java</span><br><span class="line">02:55:14 PM     36882  59060.00     12.00      0.00  java</span><br><span class="line">02:55:15 PM     36882  60844.00      4.00      0.00  java</span><br><span class="line">02:55:16 PM     36882  60624.00      0.00      0.00  java</span><br><span class="line">02:55:17 PM     36882  60828.00      0.00      0.00  java</span><br><span class="line">02:55:18 PM     36882  61384.00      0.00      0.00  java</span><br><span class="line">02:55:19 PM     36882  64644.00      0.00      0.00  java</span><br><span class="line">02:55:20 PM     36882  65768.00      0.00      0.00  java</span><br><span class="line">02:55:21 PM     36882  67020.00      0.00      0.00  java</span><br><span class="line">02:55:22 PM     36882  66268.00      0.00      0.00  java</span><br><span class="line">02:55:23 PM     36882  69688.00      0.00      0.00  java</span><br><span class="line">02:55:24 PM     36882  68328.00      0.00      0.00  java</span><br><span class="line">02:55:25 PM     36882  68916.00      0.00      0.00  java</span><br><span class="line">02:55:26 PM     36882  72812.00      0.00      0.00  java</span><br><span class="line">02:55:27 PM     36882  30740.00      8.00      0.00  java</span><br><span class="line">02:55:28 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:29 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:30 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:31 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">02:55:32 PM     36882      0.00      0.00      0.00  java</span><br><span class="line">Average:        36882  43570.88      1.12      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1759340 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     103344 kB</span><br></pre></td></tr></table></figure><p>与之前相比，无明显差别。</p><h5 id="靠后部分数据查询"><a href="#靠后部分数据查询" class="headerlink" title="靠后部分数据查询"></a>靠后部分数据查询</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 13197.228538 ms</span><br><span class="line">Avg time: 0.131972 ms</span><br><span class="line">Max time: 4.570671 ms</span><br><span class="line">Min time: 0.002547 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">03:00:51 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">03:00:52 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:00:53 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:00:54 PM     37189  27264.00     16.00      0.00  java</span><br><span class="line">03:00:55 PM     37189  33348.00      0.00      0.00  java</span><br><span class="line">03:00:56 PM     37189  33208.00      0.00      0.00  java</span><br><span class="line">03:00:57 PM     37189  35184.00      0.00      0.00  java</span><br><span class="line">03:00:58 PM     37189  36184.00      0.00      0.00  java</span><br><span class="line">03:00:59 PM     37189  36340.00      0.00      0.00  java</span><br><span class="line">03:01:00 PM     37189  35732.00      0.00      0.00  java</span><br><span class="line">03:01:01 PM     37189  35900.00      0.00      0.00  java</span><br><span class="line">03:01:02 PM     37189  35804.00      0.00      0.00  java</span><br><span class="line">03:01:03 PM     37189  37952.00      0.00      0.00  java</span><br><span class="line">03:01:04 PM     37189  38460.00      0.00      0.00  java</span><br><span class="line">03:01:05 PM     37189  39380.00      0.00      0.00  java</span><br><span class="line">03:01:06 PM     37189  38592.00      0.00      0.00  java</span><br><span class="line">03:01:07 PM     37189  26228.00      0.00      0.00  java</span><br><span class="line">03:01:08 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:09 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:10 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:11 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:12 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:13 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:14 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:15 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">03:01:16 PM     37189      0.00      0.00      0.00  java</span><br><span class="line">Average:        37189  19583.04      0.64      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1163084 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     103024 kB</span><br></pre></td></tr></table></figure><p>与之前相比，性能有较为明显地提升。</p><h5 id="混合查询-2"><a href="#混合查询-2" class="headerlink" title="混合查询"></a>混合查询</h5><p>使用混合查询用例中的测试数据（100000条）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 17523.954852 ms</span><br><span class="line">Avg time: 0.175240 ms</span><br><span class="line">Max time: 5.308643 ms</span><br><span class="line">Min time: 0.001480 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">03:08:04 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">03:08:05 PM     37460      0.00      0.00      0.00  java</span><br><span class="line">03:08:06 PM     37460      0.00      0.00      0.00  java</span><br><span class="line">03:08:07 PM     37460  37376.00     16.00      0.00  java</span><br><span class="line">03:08:08 PM     37460  50028.00      0.00      0.00  java</span><br><span class="line">03:08:09 PM     37460  52016.00      0.00      0.00  java</span><br><span class="line">03:08:10 PM     37460  52592.00      0.00      0.00  java</span><br><span class="line">03:08:11 PM     37460  52592.00      0.00      0.00  java</span><br><span class="line">03:08:12 PM     37460  54444.00      0.00      0.00  java</span><br><span class="line">03:08:13 PM     37460  56756.00      0.00      0.00  java</span><br><span class="line">03:08:14 PM     37460  56404.00      0.00      0.00  java</span><br><span class="line">03:08:15 PM     37460  54556.00      0.00      0.00  java</span><br><span class="line">03:08:16 PM     37460  57464.00      0.00      0.00  java</span><br><span class="line">03:08:17 PM     37460  56928.00      0.00      0.00  java</span><br><span class="line">03:08:18 PM     37460  59416.00      0.00      0.00  java</span><br><span class="line">03:08:19 PM     37460  59432.00      0.00      0.00  java</span><br><span class="line">03:08:20 PM     37460  62476.00      0.00      0.00  java</span><br><span class="line">03:08:21 PM     37460  61860.00      0.00      0.00  java</span><br><span class="line">03:08:22 PM     37460  62708.00      0.00      0.00  java</span><br><span class="line">03:08:23 PM     37460  62676.00      0.00      0.00  java</span><br><span class="line">03:08:24 PM     37460  63864.00      0.00      0.00  java</span><br><span class="line">03:08:25 PM     37460   2796.00      4.00      0.00  java</span><br><span class="line">03:08:26 PM     37460      0.00      8.00      0.00  java</span><br><span class="line">03:08:27 PM     37460      0.00      0.00      0.00  java</span><br><span class="line">03:08:28 PM     37460      0.00      0.00      0.00  java</span><br><span class="line">03:08:29 PM     37460      0.00      0.00      0.00  java</span><br><span class="line">Average:        37460  40655.36      1.12      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          1685812 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:     102536 kB</span><br></pre></td></tr></table></figure><p>与之前相比，性能提升不明显。</p><h5 id="验证效果-1"><a href="#验证效果-1" class="headerlink" title="验证效果"></a>验证效果</h5><p>使用内容前缀缓存后，确实能够对靠后部分数据的查询性能有一定提升。但总体上，提升效果不明显。</p><h4 id="双管齐下"><a href="#双管齐下" class="headerlink" title="双管齐下"></a>双管齐下</h4><h5 id="混合查询-3"><a href="#混合查询-3" class="headerlink" title="混合查询"></a>混合查询</h5><p>使用混合查询用例中的测试数据（100000条）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行时间</span></span><br><span class="line">Total time: 8900.574408 ms</span><br><span class="line">Avg time: 0.089006 ms</span><br><span class="line">Max time: 13.780685 ms</span><br><span class="line">Min time: 0.001219 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 磁盘I/O</span></span><br><span class="line">03:23:41 PM       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">03:23:42 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:43 PM     37684   1488.00     16.00      0.00  java</span><br><span class="line">03:23:44 PM     37684  41672.00      0.00      0.00  java</span><br><span class="line">03:23:45 PM     37684  45888.00      0.00      0.00  java</span><br><span class="line">03:23:46 PM     37684  45500.00      0.00      0.00  java</span><br><span class="line">03:23:47 PM     37684  47456.00      0.00      0.00  java</span><br><span class="line">03:23:48 PM     37684  47728.00      0.00      0.00  java</span><br><span class="line">03:23:49 PM     37684  47360.00      0.00      0.00  java</span><br><span class="line">03:23:50 PM     37684  49928.00      0.00      0.00  java</span><br><span class="line">03:23:51 PM     37684  48904.00      0.00      0.00  java</span><br><span class="line">03:23:52 PM     37684  49288.00      8.00      0.00  java</span><br><span class="line">03:23:53 PM     37684   9076.00     12.00      0.00  java</span><br><span class="line">03:23:54 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:55 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:56 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:57 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:58 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:23:59 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:00 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:01 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:02 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:03 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:04 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:05 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">03:24:06 PM     37684      0.00      0.00      0.00  java</span><br><span class="line">Average:        37684  17371.52      1.44      0.00  java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统缓存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/meminfo | grep -E <span class="string">"Cached|SReclaimable"</span></span></span><br><span class="line">Cached:          2276696 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SReclaimable:      98120 kB</span><br></pre></td></tr></table></figure><p>性能得到进一步地提升。此时系统性能已达到万级qps，查询响应也在可接受范围内。</p><h5 id="JVM的堆内存使用情况"><a href="#JVM的堆内存使用情况" class="headerlink" title="JVM的堆内存使用情况"></a>JVM的堆内存使用情况</h5><p>索引构建后的，JVM的堆内存使用情况如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 5368709120 (5120.0MB)</span><br><span class="line">   NewSize                  = 1073741824 (1024.0MB)</span><br><span class="line">   MaxNewSize               = 1073741824 (1024.0MB)</span><br><span class="line">   OldSize                  = 4294967296 (4096.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 10</span><br><span class="line">   MetaspaceSize            = 67108864 (64.0MB)</span><br><span class="line">   CompressedClassSpaceSize = 58720256 (56.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 67108864 (64.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 895483904 (854.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 895483904 (854.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 89128960 (85.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 89128960 (85.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 89128960 (85.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 89128960 (85.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 4294967296 (4096.0MB)</span><br><span class="line">   used     = 2874165616 (2741.0179290771484MB)</span><br><span class="line">   free     = 1420801680 (1354.9820709228516MB)</span><br><span class="line">   66.91938303411007% used</span><br><span class="line"></span><br><span class="line">900 interned Strings occupying 63016 bytes.</span><br></pre></td></tr></table></figure><p>整个程序占用内存最大的是老生代（大约2.7 GB），其中包含了25000000个姓名、全部的一二级索引和Bloom过滤器。与之前相比，改进后内存使用量新增了1.2 GB。如果查询场景中，数据命中率很高，可以关闭Bloom过滤器减少内存使用，毕竟此时的收益较低。</p><h3 id="5-关于JVM启动参数配置"><a href="#5-关于JVM启动参数配置" class="headerlink" title="5. 关于JVM启动参数配置"></a>5. 关于JVM启动参数配置</h3><p>启动参数设置时，主要考虑两点：</p><ul><li>老生代存储空间压力大: 需要能够存储索引、姓名字典和Bloom过滤器。</li><li>垃圾回收对查询响应的影响: 由于使用场景存在响应延迟的要求，我们需要尽量减少GC的stop-the-world事件对响应时间的影响。</li></ul><p>因此，最终JVM启动参数设置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本设置和GC日志(可用于后期性能分析)</span></span><br><span class="line">-server -XX:+AlwaysPreTouch -XX:+PrintCommandLineFlags -Xloggc:/home/gc-%t.log -XX:NumberOfGCLogFiles=5 -XX:+UseGCLogFileRotation -XX:GCLogFileSize=20m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+PrintGCCause -XX:+PrintTenuringDistribution</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置堆内存布局，保证老生代大小</span></span><br><span class="line">-Xmn1g -Xms5g -Xmx5g -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=64m -XX:-UseAdaptiveSizePolicy -XX:SurvivorRatio=10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择垃圾回收器及设置</span></span><br><span class="line">-XX:+UseConcMarkSweepGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=85 -XX:+ExplicitGCInvokesConcurrent -XX:+CMSScavengeBeforeRemark</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启内存溢出dump和错误日志</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/index.hprof -XX:ErrorFile=/home/hs_err_pid%p.log</span><br></pre></td></tr></table></figure><h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h2><p>整个过程中涉及到了不少知识点，通过整个设计实现过程，将这些知识点进行了串联和实践，有了更多地理解，也发现之前一些想当然的东西。痛并快乐着吧:P。</p><p>算是抛砖引玉吧，如果你有更好地设计或者改进，欢迎交流。</p><iframe src="//ghbtns.com/github-btn.html?user=neotse&repo=toy-index-file&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-身份证校验码计算"><a href="#1-身份证校验码计算" class="headerlink" title="1. 身份证校验码计算"></a>1. 身份证校验码计算</h3><p>第一步身份证号码（除第18位校验码外）每一位（从1开始）按照以下方法计算相应的权重：<br>$$<br>W_i = 2^{18 - i} \mod 11<br>$$<br>第二步使用计算得到权重进行身份证号码（除第18位校验码外）加权求和：<br>$$<br>S = \sum_{i=1}^{17} a_i . W_i<br>$$<br>第三步求余得到校验码$a_{18}$，如果等于10，则使用<code>X</code>表示：<br>$$<br>a_{18} = (12 - (S \mod 11))\mod 11<br>$$<br>参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">18</span>];</span><br><span class="line">System.arraycopy(oldCertNum.toCharArray(), <span class="number">0</span>, ch, <span class="number">0</span>, oldCertNum.length());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  sum += ((<span class="number">1</span> &lt;&lt; (<span class="number">17</span> - i)) % <span class="number">11</span>) * (ch[i] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> code = (<span class="number">12</span> - (sum % <span class="number">11</span>)) % <span class="number">11</span>;</span><br><span class="line">ch[<span class="number">17</span>] = code &lt; <span class="number">10</span> ? (<span class="keyword">char</span>) (<span class="string">'0'</span> + code) : <span class="string">'X'</span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom Filter</a></li><li><a href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics" target="_blank" rel="noopener">Linux Page Cache</a></li><li><a href="http://www.brendangregg.com/index.html" target="_blank" rel="noopener">Linux性能工具</a></li><li><a href="https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468" target="_blank" rel="noopener">Linux Kernel Development (3rd Edition)</a></li><li><a href="https://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz-ebook/dp/B07CVKH7BD" target="_blank" rel="noopener">Operating System Concepts (10th Edition)</a></li><li><a href="http://xxfox.perfma.com" target="_blank" rel="noopener">JVM 参数查询优化服务</a></li><li><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">Java Garbage Collection Basics</a></li><li><a href="https://www.oracle.com/technetwork/java/tuning-139912.html" target="_blank" rel="noopener">Java Tuning White Paper</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现有一文本文件，文件内容每行记录由3个字段组成，字段间以’\t’分隔，每行以’\n’分隔，3个字段分别为”身份证号码 手机号码 姓名“。现需要提供一个服务，业务可通过服务根据身份证号码或者手机号码精确查询相关记录。那么如何设计，使得查询响应延迟低、吞吐高和资源消耗低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="design" scheme="https://johntse.dev/categories/design/"/>
    
      <category term="programming" scheme="https://johntse.dev/categories/design/programming/"/>
    
    
      <category term="index" scheme="https://johntse.dev/tags/index/"/>
    
      <category term="performance" scheme="https://johntse.dev/tags/performance/"/>
    
      <category term="linux" scheme="https://johntse.dev/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何识别定位信息中的坐标系</title>
    <link href="https://johntse.dev/how-to-identify-the-coordinate-system-in-positioning-information/"/>
    <id>https://johntse.dev/how-to-identify-the-coordinate-system-in-positioning-information/</id>
    <published>2018-07-10T01:40:58.000Z</published>
    <updated>2020-05-10T06:57:00.868Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作关系会接触到一些带有定位信息的数据，而在中国地理位置信息这个事比较复杂，存在多种坐标系混用的情况。而很多时候数据中往往没有标识出具体的坐标系，如果直接使用可能会造成位置偏差等问题。这里分享一下本人的拙法（特殊地形法）。</p><a id="more"></a><h2 id="一、特殊地形选取"><a href="#一、特殊地形选取" class="headerlink" title="一、特殊地形选取"></a>一、特殊地形选取</h2><p>这里通过特殊地形法，来进行坐标系识别。</p><p><em>注：所有的经纬度采用度数表示。</em></p><h3 id="1-相关计算公式"><a href="#1-相关计算公式" class="headerlink" title="1. 相关计算公式"></a>1. 相关计算公式</h3><p>具体可参考：<a href="https://www.movable-type.co.uk/scripts/latlong.html" target="_blank" rel="noopener">Calculate distance, bearing and more between Latitude/Longitude points</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坐标表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DecimalFormat format = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.000000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> lng; <span class="comment">// 经度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> lat; <span class="comment">// 纬度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coordinate</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lng = lng;</span><br><span class="line">        <span class="keyword">this</span>.lat = lat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coordinate&#123; longitude='"</span> + format.format(lng) + <span class="string">'\''</span> </span><br><span class="line">                + <span class="string">", latitude='"</span> + format.format(lat) + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经纬度到距离"><a href="#经纬度到距离" class="headerlink" title="经纬度到距离"></a>经纬度到距离</h4><p>这里使用Harversine公式来计算两个经纬度之间的距离（单位：米）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EARTH_RADIUS = <span class="number">6371001</span>; <span class="comment">// 地球平均半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Harversine公式来计算两个经纬度之间的距离（单位：米）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng1 第一个经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat1 第一个纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng2 第二个经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat2 第二个纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 计算得到的距离，单位米</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">distHarversine</span><span class="params">(<span class="keyword">double</span> lng1， <span class="keyword">double</span> lat1, <span class="keyword">double</span> lng2, <span class="keyword">double</span> lat2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> hsinX = Math.sin(Math.toRadians(lng1 - lng2) * <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">double</span> hsinY = Math.sin(Math.toRadians(lat1 - lat2) * <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">double</span> h = hsinY * hsinY</span><br><span class="line">              + (Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) * hsinX * hsinX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * Math.atan2(Math.sqrt(h), Math.sqrt(<span class="number">1</span> - h)) * EARTH_RADIUS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方位角计算"><a href="#方位角计算" class="headerlink" title="方位角计算"></a>方位角计算</h4><p>给定两个点的经纬，可通过以下公式计算得到两点之间的方位角（从正北开始顺时针）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算起始点到目的点的方位角。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bLng 起始点经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bLat 起始点纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eLng 目的点经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eLat 目的点纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 起始点到目的点的方位角（度数表示）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initBearing</span><span class="params">(<span class="keyword">double</span> bLng, <span class="keyword">double</span> bLat, <span class="keyword">double</span> eLng, <span class="keyword">double</span> eLat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> delta = Math.toRadians(eLng - bLng);</span><br><span class="line">  <span class="keyword">double</span> bRadiusLat = Math.toRadians(bLat);</span><br><span class="line">  <span class="keyword">double</span> eRadiusLat = Math.toRadians(eLat);</span><br><span class="line">  <span class="keyword">double</span> theta = Math.atan2(Math.sin(delta) * Math.cos(eRadiusLat), Math.cos(bRadiusLat) * Math.sin(eRadiusLat) - Math.sin(bRadiusLat) * Math.cos(eRadiusLat) * Math.cos(delta));</span><br><span class="line">  <span class="keyword">return</span> (Math.toDegrees(theta) + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算目的点到起始点的方位角。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bLng 起始点经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bLat 起始点纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eLng 目的点经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eLat 目的点纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目的点到起始点的方位角（度数表示）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">finalBearing</span><span class="params">(<span class="keyword">double</span> bLng, <span class="keyword">double</span> bLat, <span class="keyword">double</span> eLng, <span class="keyword">double</span> eLat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (initBearing(bLng, bLat, eLng, eLat) + <span class="number">180</span>) % <span class="number">360</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="距离到经纬度"><a href="#距离到经纬度" class="headerlink" title="距离到经纬度"></a>距离到经纬度</h4><p>这里使用下面公式来计算给定距离、起始坐标和方位角（从正北开始顺时针）的目的坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算给定距离、起始坐标和方位角（从正北开始顺时针）的目的坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng 起始点经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat 起始点纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brng 方位角（度数表示）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> distance 距离(单位：米)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">destinationPoint</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat, <span class="keyword">double</span> brng, <span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> a = distance / EARTH_RADIUS;</span><br><span class="line">  <span class="keyword">double</span> theta = Math.toRadians(brng);</span><br><span class="line">  <span class="keyword">double</span> radiansLat = Math.toRadians(lat);</span><br><span class="line">  <span class="keyword">double</span> radiansLng = Math.toRadians(lng);</span><br><span class="line">  <span class="keyword">double</span> phi = Math.sin(radiansLat) * Math.cos(a) </span><br><span class="line">                          + Math.cos(radiansLat) * Math.sin(a) * Math.cos(theta);</span><br><span class="line">  <span class="keyword">double</span> dLat = Math.asin(phi);</span><br><span class="line">  <span class="keyword">double</span> dLng = radiansLng + Math.atan2(Math.sin(theta) * Math.sin(a) * Math.cos(radiansLat),</span><br><span class="line">                                Math.cos(a) - Math.sin(radiansLat) * phi);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Coordinate(((Math.toDegrees(dLng) + <span class="number">540</span>) % <span class="number">360</span> - <span class="number">180</span>), Math.toDegrees(dLat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-区域范围确定"><a href="#2-区域范围确定" class="headerlink" title="2. 区域范围确定"></a>2. 区域范围确定</h3><p>以杭州的西兴大桥为例。</p><p><em>注：这里坐标采用百度坐标系。</em></p><h4 id="范围划定"><a href="#范围划定" class="headerlink" title="范围划定"></a>范围划定</h4><p>大桥为西北-东南走向，位于江面长度约为1.2公里。为了应对坐标系不同的偏移情况，分别向东北和西南方向延伸1.5公里。得到一个长为3公里，宽为1.2公里的矩形。</p><h4 id="范围坐标"><a href="#范围坐标" class="headerlink" title="范围坐标"></a>范围坐标</h4><p>其中共有六个点，它们的坐标为：</p><h5 id="地形两端坐标点"><a href="#地形两端坐标点" class="headerlink" title="地形两端坐标点"></a>地形两端坐标点</h5><ul><li>大桥西北点（$x_1$）：120.216268, 30.238929</li><li>大桥东南点（$x_2$）：120.225994, 30.232221</li></ul><p>通过“方位角计算”章节给出的公式计算得到大桥方位角为$128.598^{\circ}(x_2 \rightarrow x_1)$。</p><h5 id="矩形的四个断点的坐标点"><a href="#矩形的四个断点的坐标点" class="headerlink" title="矩形的四个断点的坐标点"></a>矩形的四个断点的坐标点</h5><p>通过“距离到经纬度”章节给出的公式进行计算。其中距离为1500米，角度分别为$38.598^{\circ}$和$218.598^{\circ}$，起始点分别为$x_1$和$x_2$ 。</p><ul><li>矩形西北点（$x_a$）：120.226010, 30.249472</li><li>矩形东北点（$x_b$）：120.235735, 30.242764</li><li>矩形东南点（$x_c$）：120.216255, 30.221678</li><li>矩形西南点（$x_d$）：120.206528, 30.228386</li></ul><h4 id="区域图示"><a href="#区域图示" class="headerlink" title="区域图示"></a>区域图示</h4><p>最终得到的区域</p><img src="/how-to-identify-the-coordinate-system-in-positioning-information/特殊地形区域.png" title="特殊地形区域"><h3 id="3-区域数学描述"><a href="#3-区域数学描述" class="headerlink" title="3. 区域数学描述"></a>3. 区域数学描述</h3><p>这里我们将经纬度看作为实数。经度作为x轴，纬度作为y轴。由于区域面积很小，我们可以认为其为平面，且各个边为直线。</p><h4 id="描述方式"><a href="#描述方式" class="headerlink" title="描述方式"></a>描述方式</h4><p>这里直接采用直线$y=ax+b$来进行简单表示。因此共有五条直线来表示，其中四条表示矩形，一条表示大桥本身。</p><h4 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h4><h5 id="大桥的直线方程"><a href="#大桥的直线方程" class="headerlink" title="大桥的直线方程"></a>大桥的直线方程</h5><p>$$<br>\begin{cases}<br>120.216268 \times a + b - 30.238929 = 0 \<br>120.225994 \times a + b - 30.232221 = 0<br>\end{cases}<br>$$<br>根据<br>$$<br>\begin{cases}<br>a = \frac {y_1 - y_2} {x_1 - x_2} \<br>b = y_1 - x_1 \times a<br>\end{cases}<br>$$<br>求得<br>$$<br>L_{12}(x) =  -0.689698 \times x + 113.151815<br>$$</p><h5 id="矩形四条边的直线方程"><a href="#矩形四条边的直线方程" class="headerlink" title="矩形四条边的直线方程"></a>矩形四条边的直线方程</h5><p>和大桥的直线方程同理可以求得：</p><ul><li>$L_{ab}(x) = -0.689769 \times x + 113.177603$</li><li>$L_{bc}(x) = 1.082444 \times x - 99.905630$</li><li>$L_{cd}(x) = -0.689627 \times x + 113.1260306$</li><li>$L_{ad}(x) = 1.082332 \times x - 99.875035$</li></ul><h4 id="区域图示-1"><a href="#区域图示-1" class="headerlink" title="区域图示"></a>区域图示</h4><p>最终效果</p><img src="/how-to-identify-the-coordinate-system-in-positioning-information/特殊地形区域2.png" title="特殊地形区域2"><h3 id="4-坐标范围数据筛选"><a href="#4-坐标范围数据筛选" class="headerlink" title="4. 坐标范围数据筛选"></a>4. 坐标范围数据筛选</h3><p>确定了坐标范围，为了避免其它数据的干扰，需要筛选出指定范围内的数据。由于已经通过直线方程对范围进行了形式化，那么是否在所选定的西兴大桥区域，可按照下面的条件进行筛选。<br>$$<br>\begin{cases}<br>L_{ab}(x) \le 0 \<br>L_{bc}(x) \ge 0 \<br>L_{cd}(x) \ge 0 \<br>L_{ad}(x) \le 0<br>\end{cases}<br>$$</p><p>更一般的，我们可以进行推广为：</p><p>设直线$L12$的方位角(initBearing)为$\theta_{12}$，则有<br>$$<br>\theta_{12} \le 90^{\circ} \Longrightarrow \begin{cases}<br>L_{ab}(x) \le 0 \<br>L_{bc}(x) \le 0 \<br>L_{cd}(x) \ge 0 \<br>L_{ad}(x) \ge 0<br>\end{cases}<br>\quad ,<br>\theta_{12} \gt 90^{\circ} \Longrightarrow \begin{cases}<br>L_{ab}(x) \le 0 \<br>L_{bc}(x) \ge 0 \<br>L_{cd}(x) \ge 0 \<br>L_{ad}(x) \le 0<br>\end{cases}<br>$$</p><h3 id="5-关于区域选择"><a href="#5-关于区域选择" class="headerlink" title="5. 关于区域选择"></a>5. 关于区域选择</h3><p>人工通过地图选定几个特殊地形，并生成区域范围。通过过滤出的数据量（越多越好）来筛选合适的用于坐标系分析的特殊地形。</p><p>当然，也可以通过结合多个特殊地形的分析结果，得到更加准确的结果。</p><h3 id="6-特殊地形持久化表示"><a href="#6-特殊地形持久化表示" class="headerlink" title="6. 特殊地形持久化表示"></a>6. 特殊地形持久化表示</h3><p>为了复用，对特性地形进行持久化存储。其中存储方式采用json文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"lines"</span>: &#123;</span><br><span class="line">    <span class="attr">"FirstLine"</span>: &#123;</span><br><span class="line">      <span class="attr">"coefficients"</span>: [</span><br><span class="line">        <span class="number">113.18239016103625</span>,</span><br><span class="line">        <span class="number">-0.6897605959829629</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"endpoints"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.22925792992226</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.252985556703706</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.2389830430509</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.246277556876095</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"checkFlag"</span>: <span class="string">"LessEqual"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"SecondLine"</span>: &#123;</span><br><span class="line">      <span class="attr">"coefficients"</span>: [</span><br><span class="line">        <span class="number">-99.89916529550732</span>,</span><br><span class="line">        <span class="number">1.0823897504670807</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"endpoints"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.2389830430509</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.246277556876095</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.21300867072875</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.218163162499796</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"checkFlag"</span>: <span class="string">"GreatEqual"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ThirdLine"</span>: &#123;</span><br><span class="line">      <span class="attr">"coefficients"</span>: [</span><br><span class="line">        <span class="number">113.12124983242019</span>,</span><br><span class="line">        <span class="number">-0.6896349037981184</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"endpoints"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.21300867072875</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.218163162499796</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.20328178511033</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.22487116232751</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"checkFlag"</span>: <span class="string">"GreatEqual"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"FourthLine"</span>: &#123;</span><br><span class="line">      <span class="attr">"coefficients"</span>: [</span><br><span class="line">        <span class="number">-99.87305113862793</span>,</span><br><span class="line">        <span class="number">1.0823158932842945</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"endpoints"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.22925792992226</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.252985556703706</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.20328178511033</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.22487116232751</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"checkFlag"</span>: <span class="string">"LessEqual"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"SpecialLine"</span>: &#123;</span><br><span class="line">      <span class="attr">"coefficients"</span>: [</span><br><span class="line">        <span class="number">113.151814640954</span>,</span><br><span class="line">        <span class="number">-0.6896977174582894</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"endpoints"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.216268</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.238929</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">120.225994</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">30.232221</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"checkFlag"</span>: <span class="string">"Equal"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、坐标系分析"><a href="#二、坐标系分析" class="headerlink" title="二、坐标系分析"></a>二、坐标系分析</h2><h3 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a>1. 坐标系</h3><p>由于各类原因，国内坐标系统使用情况比较复杂，目前已知的有：</p><table><thead><tr><th>坐标系</th><th>说明</th></tr></thead><tbody><tr><td>WGS-84</td><td>国际通用坐标系或者称大地坐标系，国外及港澳台常用</td></tr><tr><td>GCJ-02</td><td>中国特色，又称为火星坐标系或者国测局坐标系，国内地图服务商必须使用</td></tr><tr><td>BD-09</td><td>百度坐标系，在GCJ-02基础上进一步进行加偏处理</td></tr><tr><td>图吧坐标系</td><td>目前图吧地图使用，在GCJ-02基础上进一步进行加偏处理</td></tr><tr><td>搜狗坐标系</td><td>目前搜狗地图使用，在GCJ-02基础上进一步进行加偏处理</td></tr></tbody></table><h3 id="2-坐标系转换"><a href="#2-坐标系转换" class="headerlink" title="2. 坐标系转换"></a>2. 坐标系转换</h3><p><em>注：这里目前只有三大坐标系转换算法</em></p><h4 id="WGS-84-与-GCJ-02"><a href="#WGS-84-与-GCJ-02" class="headerlink" title="WGS-84 与 GCJ-02"></a>WGS-84 与 GCJ-02</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.sin;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.cos;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.sqrt;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.abs;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.atan2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> a = <span class="number">6378245.0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> ee = <span class="number">0.00669342162296594323</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLat</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ret = -<span class="number">100.0</span> + <span class="number">2.0</span> * lng + <span class="number">3.0</span> * lat + <span class="number">0.2</span> * lat * lat </span><br><span class="line">    + <span class="number">0.1</span> * lng * lat + <span class="number">0.2</span> * sqrt(abs(lng));</span><br><span class="line">  ret += (<span class="number">20.0</span> * sin(<span class="number">6.0</span> * lng * PI) + <span class="number">20.0</span> * sin(<span class="number">2.0</span> * lng * PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  ret += (<span class="number">20.0</span> * sin(lat * PI) + <span class="number">40.0</span> * sin(lat / <span class="number">3.0</span> * PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  ret += (<span class="number">160.0</span> * sin(lat / <span class="number">12.0</span> * PI) + <span class="number">320</span> * sin(lat * PI / <span class="number">30</span>)) * <span class="number">2.0</span> /<span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">transformLng</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ret = <span class="number">300.0</span> + lng + <span class="number">2.0</span> * lat + <span class="number">0.1</span> * lng * lng + <span class="number">0.1</span> * lng * lat </span><br><span class="line">    + <span class="number">0.1</span> * sqrt(abs(lng));</span><br><span class="line">  ret += (<span class="number">20.0</span> * sin(<span class="number">6.0</span> * lng * PI) + <span class="number">20.0</span> * sin(<span class="number">2.0</span> * lng * PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  ret += (<span class="number">20.0</span> * sin(lng * PI) + <span class="number">40.0</span> * sin(lng / <span class="number">3.0</span> * PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  ret += (<span class="number">150.0</span> * sin(lng / <span class="number">12.0</span> * PI) + <span class="number">300.0</span> * sin(lng / <span class="number">30.0</span> * PI)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WGS-84坐标系转GCJ-02坐标系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的坐标对象（GCJ-02坐标系）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">wgsToGcj</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> dLat = transformLat(lng - <span class="number">105.0</span>, lat - <span class="number">35.0</span>);</span><br><span class="line">  <span class="keyword">double</span> dLng = transformLng(lng - <span class="number">105.0</span>, lat - <span class="number">35.0</span>);</span><br><span class="line">  <span class="keyword">double</span> radLat = lat / <span class="number">180.0</span> * PI;</span><br><span class="line">  <span class="keyword">double</span> magic = sin(radLat);</span><br><span class="line">  magic = <span class="number">1</span> - ee * magic * magic;</span><br><span class="line">  <span class="keyword">double</span> sqrtMagic = sqrt(magic);</span><br><span class="line">  dLat = (dLat * <span class="number">180.0</span>) / ((a * (<span class="number">1</span> - ee)) / (magic * sqrtMagic) * PI);</span><br><span class="line">  dLng = (dLng * <span class="number">180.0</span>) / (a / sqrtMagic * cos(radLat) * PI);</span><br><span class="line">  <span class="keyword">double</span> mgLat = lat + dLat;</span><br><span class="line">  <span class="keyword">double</span> mgLng = lng + dLng;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Coordinate(mgLng, mgLat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GCJ-02坐标系转WGS-84坐标系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的坐标对象（WGS-84）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">gcjToWgs</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  Coordinate temp = wgsToGcj(lng, lat);</span><br><span class="line">  <span class="keyword">double</span> wLng = lng * <span class="number">2</span> - temp.lng;</span><br><span class="line">  <span class="keyword">double</span> wLat = lat * <span class="number">2</span> - temp.lat;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Coordinate(wLng, wLat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体请参考：<a href="https://blog.genglinxiao.com/%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E5%81%8F%E7%A7%BB%E7%AE%97%E6%B3%95%E7%A0%B4%E8%A7%A3%E5%B0%8F%E5%8F%B2/" target="_blank" rel="noopener">中国地图坐标(GCJ-02)偏移算法破解小史</a> 。</p><h4 id="GCJ-02-与-BD-09"><a href="#GCJ-02-与-BD-09" class="headerlink" title="GCJ-02 与 BD-09"></a>GCJ-02 与 BD-09</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> X_PI = PI * <span class="number">3000.0</span> / <span class="number">180.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GCJ-02坐标系转BD-09坐标系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的坐标对象（BD-09）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">gcjToBd</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> z = sqrt(lng * lng + lat * lat) + <span class="number">0.00002</span> * sin(lat * X_PI);</span><br><span class="line">  <span class="keyword">double</span> theta = atan2(lat, lng) + <span class="number">0.000003</span> * cos(lng * X_PI);</span><br><span class="line">  <span class="keyword">double</span> bdLng = z * cos(theta) + <span class="number">0.0065</span>;</span><br><span class="line">  <span class="keyword">double</span> bdLat = z * sin(theta) + <span class="number">0.006</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Coordinate(bdLng, bdLat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BD-09坐标系转GCJ-02坐标系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的坐标对象（GCJ-02）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">bdToGcj</span><span class="params">(<span class="keyword">double</span> lng, <span class="keyword">double</span> lat)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> x = lng - <span class="number">0.0065</span>, y = lat - <span class="number">0.006</span>;</span><br><span class="line">  <span class="keyword">double</span> z = sqrt(x * x + y * y) - <span class="number">0.00002</span> * sin(y * X_PI);</span><br><span class="line">  <span class="keyword">double</span> theta = atan2(y, x) - <span class="number">0.000003</span> * cos(x * X_PI);</span><br><span class="line">  <span class="keyword">double</span> gLng = z * cos(theta);</span><br><span class="line">  <span class="keyword">double</span> gLat = z * sin(theta);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Coordinate(gLng, gLat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换精度测试"><a href="#转换精度测试" class="headerlink" title="转换精度测试"></a>转换精度测试</h4><h5 id="与大厂提供的接口比较"><a href="#与大厂提供的接口比较" class="headerlink" title="与大厂提供的接口比较"></a>与大厂提供的接口比较</h5><p><em>注：百度使用<a href="lbsyun.baidu.com/index.php?title=jspopular">JavaScript API</a>进行转换测试，高德使用<a href="https://lbs.amap.com/api/webserivce/guide/api/convert" target="_blank" rel="noopener">Webservice</a>进行转换测试。</em></p><table><thead><tr><th>测试项</th><th>测试经纬度</th><th>百度</th><th>高德</th><th>实现算法</th></tr></thead><tbody><tr><td>WGS-84转GCJ-02</td><td>118.744288<br>31.996022</td><td>118.749512<br>31.994002</td><td>118.749507<br>31.993998</td><td>118.749507<br>31.993998</td></tr><tr><td>WGS-84转BD-09</td><td>118.744288<br>31.996022</td><td>118.756083<br>31.999686</td><td>N/A</td><td>118.756078<br>31.999682</td></tr><tr><td>GCJ-02转WGS-84</td><td>118.744288<br>31.996022</td><td>N/A</td><td>N/A</td><td>118.739069<br>31.998046</td></tr><tr><td>GCJ-02转BD-09</td><td>118.744288<br>31.996022</td><td>118.750867<br>32.001671</td><td>N/A</td><td>118.750867<br>32.001671</td></tr><tr><td>BD-09转GCJ-02</td><td>118.744288<br>31.996022</td><td>118.737702<br>31.990378</td><td>118.737702<br>31.990378</td><td>118.737702<br>31.990378</td></tr><tr><td>BD-09转WGS-84</td><td>118.744288<br>31.996022</td><td>N/A</td><td>N/A</td><td>118.732487<br>31.992403</td></tr></tbody></table><p>结论：实现算法和大厂转换精度基本一致。</p><h5 id="连续转换时的精度变化"><a href="#连续转换时的精度变化" class="headerlink" title="连续转换时的精度变化"></a>连续转换时的精度变化</h5><table><thead><tr><th>测试项</th><th>测试经纬度</th><th>转换后结果</th><th>偏差量(单位：米)</th></tr></thead><tbody><tr><td>WGS-84=&gt;GCJ-02=&gt;WGS-84</td><td>118.744288<br>31.996022</td><td>118.744287<br>31.996021</td><td>0.150</td></tr><tr><td>WGS-84=&gt;BD-09=&gt;WGS-84</td><td>118.744288<br>31.996022</td><td>118.744287<br>31.996020</td><td>0.223</td></tr><tr><td>GCJ-02=&gt;BD-09=&gt;GCJ-02</td><td>118.744288<br>31.996022</td><td>118.744288<br>31.996022</td><td>0.046</td></tr></tbody></table><p>以<code>WGS-84=&gt;BD-09=&gt;WGS-84</code>精度丢失最大为例，我们通过反复转换，测试其精度丢失情况。</p><table><thead><tr><th>转换次数</th><th>输入经纬度</th><th>输出经纬度</th><th>偏差量(单位：米)</th></tr></thead><tbody><tr><td>1</td><td>118.744288<br>31.996022</td><td>118.744287<br>31.996020</td><td>0.223</td></tr><tr><td>2</td><td>118.744287<br>31.996020</td><td>118.744286<br>31.996018</td><td>0.446</td></tr><tr><td>3</td><td>118.744286<br>31.996018</td><td>118.744285<br>31.996016</td><td>0.670</td></tr><tr><td>4</td><td>118.744285<br>31.996016</td><td>118.744285<br>31.996015</td><td>0.893</td></tr><tr><td>5</td><td>118.744285<br>31.996015</td><td>118.744284<br>31.996013</td><td>1.116</td></tr><tr><td>6</td><td>118.744284<br>31.996013</td><td>118.744283<br>31.996011</td><td>1.340</td></tr><tr><td>7</td><td>118.744283<br>31.996011</td><td>118.744282<br>31.996009</td><td>1.563</td></tr><tr><td>8</td><td>118.744282<br>31.996009</td><td>118.744281<br>31.996007</td><td>1.786</td></tr><tr><td>9</td><td>118.744281<br>31.996007</td><td>118.744280<br>31.996005</td><td>2.010</td></tr><tr><td>10</td><td>118.744280<br>31.996005</td><td>118.744279<br>31.996003</td><td>2.233</td></tr></tbody></table><p>可以看到每转换一次，精度丢失<strong>0.223</strong>米。</p><p>结论：连续转换时会出现精度丢失，但在可接受范围内。</p><h3 id="3-坐标系识别"><a href="#3-坐标系识别" class="headerlink" title="3. 坐标系识别"></a>3. 坐标系识别</h3><h4 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h4><p>由于大桥为简单直线，所以这里采用简单一元线性回归来对应用上报经纬度进行拟合。具体使用<em>Apache Commons Math3</em>中的<code>PolynomialCurveFitter</code>实现。</p><h5 id="密度"><a href="#密度" class="headerlink" title="密度"></a>密度</h5><p>由于选取地形缘故，坐标点有很大的概率落入到地形直线一定范围内（可能在坐标系转换后）。也就是这些范围内的点数要明显高于周围其它范围。造成了明显的高密度区域。这里我们将密度定义为</p><blockquote><p>设选定范围宽为$W$，地形长为$L$，而在选定范围内有$m$个点。则有密度<br>$$<br>D = \frac {m} {2 \times (W+L)}<br>$$<br>又因为$L$在指定地形下是常量，且等分的情况下，$W$也是常量，有<br>$$<br>D \propto  m<br>$$</p></blockquote><p><em>以下使用$m$来指代密度。</em></p><h5 id="密度分布"><a href="#密度分布" class="headerlink" title="密度分布"></a>密度分布</h5><p>以地形直线为中心，将选定区域划分为等长的子区域，计算出各个子区域的密度，最终得到整个选定区域的密度分布情况。其中子区域长度可配置。</p><h5 id="高密度区域"><a href="#高密度区域" class="headerlink" title="高密度区域"></a>高密度区域</h5><p>对于非地形区域，噪音点可以看做随机分布。由于地形区域密度显著高于其它区域，这里通过应用（单边）切比雪夫不等式，来进行高密度区域选取。计算出平均密度$\overline {\sigma}$和密度标准差$\overline {\mu}$，如果区域的密度高于$\overline {\sigma} + \lambda \cdot \overline{\mu}$ ，则认为该区域为所谓的高密度区域。如果坐标系合适，那么地形直线所在区域往往是高密度区域。其中$\lambda$为可配置系数。</p><h5 id="拟合确认"><a href="#拟合确认" class="headerlink" title="拟合确认"></a>拟合确认</h5><p>确定地形直线所在区域为高密度区域后，尝试进行线性拟合，并计算偏差距离。如果在可接受范围内，则可以确认坐标系。否则，确认失败。这里主要验证区域内坐标点是否沿地形分布，避免出现聚集而误判。</p><h4 id="偏差度量"><a href="#偏差度量" class="headerlink" title="偏差度量"></a>偏差度量</h4><p>为了测试拟合后的直线和大桥直线重合程度，这里通过<code>两端平均偏差距离</code>来衡量。</p><blockquote><p>所谓两端平均偏差距离是指拟合后的直线与矩形区域两个边（比如上面的$L_{bc}$和$L_{ad}$）的两个交点（$C_{bc}, C_{ad}$）分别与地形直线端点$x_1, x_2$之间距离的平均值，即$\frac {Distance(C_{bc}, x_2) - Distance(C_{ad}, x_1)} {2}$</p></blockquote><p>两端平均偏差距离越小说明重合程度越好，具体可通过阈值来控制可接受偏差程度。</p><p>其中直线交点使用<em>Apache Commons Math3</em>中的<code>DecompositionSolver</code>实现，交点之间的距离计算可参考“经纬度到距离”章节。</p><h4 id="坐标系猜测"><a href="#坐标系猜测" class="headerlink" title="坐标系猜测"></a>坐标系猜测</h4><p>当线性拟合结果和大桥之间的偏差距离过大（默认可接受偏差为50米），需要对拟合的坐标进行坐标系转换。由于不确定坐标系，因此采用以下顺序进行转换尝试：</p><ul><li>GCJ-02到BD-09</li><li>WGS-84到BD-09</li></ul><p>并将转换后的结果，再次计算偏差距离。验证偏差是否在可接受范围内。如果多次尝试后，依然无法满足，则枚举猜测失败。</p><h3 id="4-多地形识别"><a href="#4-多地形识别" class="headerlink" title="4. 多地形识别"></a>4. 多地形识别</h3><p>为了解决单个地形数据局限性导致的部分应用由于数据太少，导致无法识别。这里引入多地形识别，即同时选取多个地形进行判断，识别结果为多个地形投票结果。</p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><h3 id="1-方法可用性"><a href="#1-方法可用性" class="headerlink" title="1. 方法可用性"></a>1. 方法可用性</h3><p>通过测试发现，本方法识别性能良好，并且受噪音影响较小。特别地，通过多地形识别，有效地提高了识别率。</p><h3 id="2-方法局限性"><a href="#2-方法局限性" class="headerlink" title="2. 方法局限性"></a>2. 方法局限性</h3><ul><li>由于通过特殊地形方只选取了极少部分数据，数据覆盖不全。只能判断应用上报数据的坐标系包含某某坐标系，而不能确认应用上报数据只包含某某坐标系</li><li>同样由于通过特殊地形只选取了极少部分数据，会出现坐标系无法判断的情况</li></ul><h3 id="3-关于坐标系"><a href="#3-关于坐标系" class="headerlink" title="3. 关于坐标系"></a>3. 关于坐标系</h3><p>从实际数据中发现，在某些小区域范围内的WGS84和GCJ02之间的偏移很小，导致误识别的发生。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作关系会接触到一些带有定位信息的数据，而在中国地理位置信息这个事比较复杂，存在多种坐标系混用的情况。而很多时候数据中往往没有标识出具体的坐标系，如果直接使用可能会造成位置偏差等问题。这里分享一下本人的拙法（特殊地形法）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="engineering" scheme="https://johntse.dev/categories/engineering/"/>
    
    
      <category term="algorithm" scheme="https://johntse.dev/tags/algorithm/"/>
    
      <category term="lbs" scheme="https://johntse.dev/tags/lbs/"/>
    
  </entry>
  
  <entry>
    <title>大数据工程师能力指南</title>
    <link href="https://johntse.dev/big-data-engineer-job-requirements/"/>
    <id>https://johntse.dev/big-data-engineer-job-requirements/</id>
    <published>2018-06-09T02:27:25.000Z</published>
    <updated>2020-05-10T06:36:32.570Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙于部门招人，为了能够较好地进行招聘和筛选，搞了这个指南。</p><a id="more"></a><h2 id="一、岗位职责"><a href="#一、岗位职责" class="headerlink" title="一、岗位职责"></a>一、岗位职责</h2><ol><li>自身具有一定的相关知识储备。了解分布式系统的概念和理论，比如CAP，BASE，FLP，sharding和replicate机制，一致性算法</li><li>熟悉公司的大数据平台，能够基于平台开发实现数据处理和加工应用，与算法工程师或者数据挖掘工程师一起实现算法落地和数据管道搭建</li><li>解决大数据量下的程序性能问题，提高和优化数据处理和加工效率</li><li>了解数据仓库概念，熟悉数据仓库构建过程和部门数据仓库架构设计，能够基于公司大数据平台实现和改进数据仓库</li><li>清楚自身在整个数据治理过程中的角色和定位，了解上下游的工作内容。充分发挥自己在质量过程中的作用</li></ol><h2 id="二、-硬实力-80"><a href="#二、-硬实力-80" class="headerlink" title="二、 硬实力(80%)"></a>二、 硬实力(80%)</h2><h3 id="1-编程能力-50"><a href="#1-编程能力-50" class="headerlink" title="1. 编程能力(50%)"></a>1. 编程能力(50%)</h3><p>主要考察面试者程序编写能力水平和常用语言的熟悉程度。侧面反映面试者的知识深度和广度、学习能力和性格。</p><p>考察点：</p><ul><li>数据结构(15%)：<ul><li>常见数据结构有哪些，有哪些操作？给你一个数组，你能实现哪些数据结构</li><li>jdk中的实现和使用</li><li>现实项目中使用过的数据结构介绍</li><li>给出一个实际应用场景，设计相应的数据结构</li><li>(可选) 你见过哪些设计精妙的数据结构，能否讲讲精妙之处</li></ul></li><li>算法(15%)：<ul><li>算法设计有哪些模式，算法复杂度是指什么，如何评估一个算法</li><li>经典算法包括排序和搜索，各举一个例子进行说明</li><li>jdk中的算法</li><li>现实项目中使用过的算法介绍</li><li>给出一个实际应用场景(给定时间复杂度或者空间复杂度)，给出相应的算法</li><li>(可选) 听过哪些机器学习算法，能够详细说明一个</li><li>(可选) 大数据环境下使用过哪些算法，遇到哪些问题，怎么解决的</li></ul></li><li>并发/并行(20%)：<ul><li>什么是并发，什么是并行，有什么区别。比如在单核和多核(甚至多CPU)机器上</li><li>常见的一些并发模式，比如生成者，消费者，线程池等，常见的并发问题和解决方法。比如线程的多少如何决策、线程饥饿、线程池停止、惊群现象等</li><li>什么是悲观锁和乐观锁？java中是哪种锁机制？CAS(CompareAndSwap)是什么，有哪些问题(ABA)？java有哪些实现？内存屏障是什么？</li><li>jdk中和并发相关的组件，比如对象锁、CountDownLatch、Cyclicbarrier、executor、并发容器、Fork/Join等.</li><li>java中的线程状态有哪些？它们之间的状态是如何转换的？新建、运行、等待、阻塞和结束</li><li>java中有哪些线程安全的类？这些类一定是线程安全的吗？如果不是，能否举个例子？</li><li>什么是异步，什么是同步，何时使用，举个例子。BIO/NIO/AIO是什么，说一下区别？</li><li>实现过哪些并行程序，和并发的区别，有什么特点?</li><li>(可选) 给出一个实际应用场景(比如HTTP server)，如何利用并发或者并行来提高性能</li><li>(可选) 除了通过锁机制解决并发问题，还有哪些方法可解决这类问题</li></ul></li><li>Java(40%)：<ul><li>介绍一下Java，强类型，静态类型，显式，支持面向对象和部分函数范式</li><li>jdk目前最新正式版本是多少，能否说一下1.7、1.8、1.9中引入的一些新特性</li><li>jvm有几种模式，32位和64位有什么区别</li><li>能说一下jvm中的内存分配策略和回收机制吗，哪些启动参数会影响gc</li><li>jdk中有哪些命令行工具，用过哪些呢</li><li>内存模型，原子性、可见性和有序性，volatile变量作用是什么，什么是happens-before</li><li>简述类加载机制，举个例子</li><li>自动装箱、拆箱(空指针问题)</li><li>泛型及类型擦除和PECS(Producer extend, Consumer super)</li><li>重载和重写，各自的判断依据是什么</li><li>序列化和反序列化机制，如何实现层级较深类的序列化和反序列化</li><li>java是值传递还是引用传递</li><li>反射机制，有哪些应用</li><li>说一说，java IO包的内容</li><li>(可选) 能说一下JVM-Based语言吗？Clojure, Groovy, Scala, JRuby, Jython</li></ul></li><li>设计模式(10%)：<ul><li>说几个设计原则(SOLID)：开闭原则、里氏替换、单一责任、依赖倒置、接口隔离、迪米特法则</li><li>模式总体来说分为哪几类：创建类、结构类和行为类</li><li>jdk中用到的设计模式</li><li>日常使用的框架、程序库或者生活中发现过哪些设计模式的应用</li><li>设计一个单例或者其它设计模式应用实例</li><li>(可选) 设计模式对比，比如命令模式和责任链模式、观察者模式和中介者模式</li></ul></li></ul><p>加分项(10%)：</p><ul><li>了解和使用过其他语言，并能够和常用语言进行对比，对计算机语言概念有了解</li><li>参加过线下/线上编程竞赛</li><li>实现过编译器或者DSL</li><li>了解函数式编程</li><li>项目中通过设计和实现过数据结构和算法解决过问题</li></ul><h3 id="2-大数据-30"><a href="#2-大数据-30" class="headerlink" title="2. 大数据(30%)"></a>2. 大数据(30%)</h3><p>主要考察面试者大数据方面相关知识和应用水平，以及”数据感”。</p><p>考察点：</p><ul><li><p>数据相关(10%)：</p><ul><li>接触过或者处理过最大的数据量是多少，做过何种处理</li><li>数据主要来源是什么？互联网是否爬取过数据？爬取规模多大，遇到过哪些反爬虫机制，如何解决的</li><li>说一下数据在各存储介质中的传输速率，能否说明计算机的存储体系。数据从磁盘如何到CPU进而被处理，处理后的数据如何写入到磁盘。比如缺页中断，磁盘块大小等</li><li>磁盘随机写和顺序写有什么不同，什么时候使用同步IO，什么时候使用异步IO</li></ul></li><li><p>大数据基础(10%)：</p><ul><li>是否阅读过Google三大论文：GFS、MapReduce和BigTable，三者的作用</li><li>介绍一下hadoop生态，听过哪些，用过哪些，能否简单介绍一下其中的一两个。比如hdfs、hbase、YARN、Zookeeper、Mapreduce、Spark、Hive、Flume、Kafka等</li><li>大数据处理时为解决存储和计算的问题，使用的是横向扩展还是纵向扩展，这样做会引入什么问题，如何解决的</li><li>说一下CAP/BASE，引申出一致性问题</li><li>说一下sharding和replication有什么区别，各自解决什么问题</li><li>什么是计算本地化？</li></ul></li><li><p>文件系统/HDFS(15%)：</p><ul><li>说一下HDFS的基本框架(Master/Slaver)</li><li>数据写入/读取流程，一个进程写入文件时，其它进程何时才能可见/可读。这里读写一致性如何？HDFS集群最小需要多少台机器</li><li>NameNode中存储哪些信息，为什么这么做？ HDFS存储文件数有上限吗，是什么原因导致的(是否有解决方案呢)。NameNode是如何保证这些存储的信息安全的？为什么要引入SecondaryNameNode，它的工作是什么，解决了单点故障吗？那如何解决单点故障问题呢？Zookeeper + QJM</li><li>DataNode中存储什么信息？选择副本存储位置时采用什么策略(机架感知)，为什么这么做？DataNode上存储的块一般大于64MB，这样做有什么好处？写入数据时，副本是如何进行的？</li><li>HDFS对小文件支持如何，原因有哪些？</li><li>HDFS是否哪些文件操作？</li><li>HDFS有哪些命令？</li><li>是否还知道哪些其它的分布式文件系统，比如Ceph, Amazon 3S, Alluxio等</li></ul></li><li><p>计算框架(20%)：</p><ul><li>MapReduce属于哪种计算范式，Spark呢？还有哪些计算范式？批量、迭代、流式、交互式、实时。每种范式能否给出一个开源框架</li><li>说明一下MapReduce基本流程，map, sort, shuffle, merge, reduce。这种方式有什么局限性</li><li>Spark基本流程，和MapReduce相比，有什么优势</li><li>在MapReduce和Spark上实现TopN算法</li><li>MapReduce二次排序如何实现，使用场景</li><li>项目中使用过哪些计算框架或者范式，结合业务说明使用场景</li><li>(可选) 实际项目中实现过哪些ETL，是否使用过工作流框架(比如Oozie，Cascading)</li></ul></li><li><p>协作(5%)：</p><ul><li>知道哪些分布式一致性算法，它们都是用来做什么的？</li><li>zookeeper的基本架构和使用场景，你接触的哪些大数据系统中使用它，它承担什么角色？统一命名服务、配置管理、集群管理(选主和资源定位)、共享锁等。能说一下其中的ZAB算法吗？zookeeper提供哪些保证？顺序一致性、原子性、及时性。</li><li>zookeeper提供哪些操作？其中的节点分为哪几种类型？</li></ul></li><li><p>数据存储(10%)：</p><ul><li>什么是NOSQL，知道哪些？能挑出两个说说它们有什么区别吗？</li><li>说明一下HBase架构，它的一致性如何？CAP中满足哪两个？HBase读写流程，初次读写时有何不同？HBase有哪些优化手段，表设计时需要注意哪些？可以结合实际项目说明。大批量数据入HBase时，比如一天几十亿数据，怎么实现？是否了解二级索引？有没有哪些场景HBase不适用呢？事务，join</li><li>是否了解图存储，图的基本概念：度、子图、连通性，有哪些类型的图？图的存储表示有哪些？图的遍历及相关算法？Dijkstra’s 算法，Bellman-Ford算法</li><li>是否使用过Solr或者ElasticSearch，介绍一下全文检索，基础概念：比如正排和倒排、相似度(编辑距离、余弦相似度等)、词频(TF)/逆文词频(IDF)、查全/查准、分词(需要做哪些处理)、文档相关度等</li></ul></li><li><p>数据集成(10%)：</p><ul><li>是否使用过Flume、Sqoop、Kafka或者Logstash，使用场景是什么？</li><li>如何与计算框架进行集成的？</li></ul></li><li><p>数据分析(5%)：</p><ul><li>使用过哪些数据分析相关：Hive，Spark SQL，Pig，Mahout等</li><li>进行过什么数据分析，支撑过什么业务？</li><li>hive中sort by, order by, distribute by, cluster by功能和区别</li><li>(可选) 你熟悉哪些机器学习算法，能详细讲解一下吗？</li></ul></li></ul><p>加分项(15%)：</p><ul><li>参与过数据仓库或者数据挖掘相关项目</li></ul><h3 id="3-Dev-Ops-20"><a href="#3-Dev-Ops-20" class="headerlink" title="3. Dev/Ops(20%)"></a>3. Dev/Ops(20%)</h3><p>考察面试者在工程化方面的经验，反应面试者的综合素质。</p><ul><li>操作系统/Linux(40%)：<ul><li>听过哪些发行版本？使用过哪些发现版本？两大常见版本：Debian系和Red Hat系</li><li>简述一下Linux的目录结构，每个目录存储内容</li><li>使用方式是什么？图像界面还是终端，用过哪些终端命令？(文本操作、进程监控、网络等)是否写过Bash Script？</li><li>是否安装过软件，如何安装的？什么是包管理器，用过哪些</li><li>如何知道程序是否允许正常，资源使用情况？如果出现性能问题，如何排查性能瓶颈？内存使用、磁盘读写、网络流量、系统中断调用等</li><li>是否在Linux的集群上搭建过大数据相关平台，比如Hadoop，Spark等</li></ul></li><li>软件工程(40%)：<ul><li>版本如何管理？你用过哪些版本管理工具？能说一下他们的有缺点吗？</li><li>如何保证代码质量的？checkstyle，findbugs？是否写过单元测试？使用过哪些测试框架？CI/CD？做过代码评审吗？</li><li>Java项目是如何管理的，maven? Gradle? 为什么要使用</li><li>听过这些吗？KISS(Keep it simple and stupid), YAGNI(You aren’t gonna need it), DRY(Don’t repeat youself)</li><li>软件开发流程有哪些？经历过哪些？喜欢哪种开发方式？</li><li>最近一次重构是什么时候？为什么？</li><li>编写代码使用何种IDE或者文本编辑器</li></ul></li></ul><p>加分项(20%)：</p><ul><li>捣鼓过Linux系统，比如自己构建一个版本</li><li>使用脚本实现自动化</li><li>使用过git/github</li><li>有代码洁癖，对代码要求较高</li></ul><h2 id="三、软实力-20"><a href="#三、软实力-20" class="headerlink" title="三、软实力(20%)"></a>三、软实力(20%)</h2><h3 id="1-领导-创建团队-20"><a href="#1-领导-创建团队-20" class="headerlink" title="1. 领导/创建团队(20%)"></a>1. 领导/创建团队(20%)</h3><ul><li>在之前的项目中承担什么样的角色，主要的工作职能是什么？</li><li>未来自己是倾向于开发还是管理，对技术怎么看</li><li>是否担任过领导者角色，和单纯开发人员有什么区别？角色带来了什么成长</li><li>带领团队完成哪些工作？值得称赞的有什么</li></ul><h3 id="2-学习分享-50"><a href="#2-学习分享-50" class="headerlink" title="2. 学习分享(50%)"></a>2. 学习分享(50%)</h3><ul><li>参加工作时，是否和别人分享过学习成果或者经验？效果如何？</li><li>对哪块技术感兴趣，是否关注业界发展？平时信息获取途径有哪些？</li><li>如何学习一门新技术的？最近关心哪些新技术？能否简单介绍一个？</li><li>最近是否有学习计划？</li></ul><h3 id="3-业余时间-15"><a href="#3-业余时间-15" class="headerlink" title="3. 业余时间(15%)"></a>3. 业余时间(15%)</h3><ul><li>是否有自己的技术博客</li><li>是否有自己的开源项目</li><li>除了技术，是否还有其它业余爱好？</li></ul><p>加分项(15%)：</p><ul><li>带领过团队</li><li>有大数据相关的开源项目</li><li>有大数据相关的技术博客</li><li>对大数据感兴趣，并且对这块信息比较关注</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙于部门招人，为了能够较好地进行招聘和筛选，搞了这个指南。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thinking" scheme="https://johntse.dev/categories/thinking/"/>
    
    
      <category term="ability" scheme="https://johntse.dev/tags/ability/"/>
    
      <category term="big data" scheme="https://johntse.dev/tags/big-data/"/>
    
      <category term="jobs" scheme="https://johntse.dev/tags/jobs/"/>
    
  </entry>
  
  <entry>
    <title>说说地址标准化过程中使用的一些数据结构和算法</title>
    <link href="https://johntse.dev/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/"/>
    <id>https://johntse.dev/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/</id>
    <published>2018-05-18T05:40:38.000Z</published>
    <updated>2020-05-10T06:22:10.066Z</updated>
    
    <content type="html"><![CDATA[<p>地址标准化在数据处理过程中算是一个比较常见的需求，这里说说个人在地址标准化过程中的一些实现思路和算法，抛砖引玉。</p><a id="more"></a><h2 id="字典分词"><a href="#字典分词" class="headerlink" title="字典分词"></a>字典分词</h2><p>地址主题库构建过程中需要通过分词来对地址做进一步的处理，目前使用的是字典分词，其可以理解为关键词匹配问题。</p><h3 id="单个关键词匹配"><a href="#单个关键词匹配" class="headerlink" title="单个关键词匹配"></a>单个关键词匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String keyword = <span class="string">"南京"</span>;</span><br><span class="line">String content = <span class="string">"南京市鼓楼区南京大学"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt; content.length() &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((index = content.indexOf(keyword, start)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(content.substring(start, index));</span><br><span class="line">    start += index;</span><br><span class="line">    System.out.println(keyword);</span><br><span class="line">    start += keyword.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(content.substring(start));</span><br></pre></td></tr></table></figure><p>匹配结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">南京</span><br><span class="line">市鼓楼区</span><br><span class="line">南京</span><br><span class="line">大学</span><br></pre></td></tr></table></figure><p>匹配的时间复杂度为<strong>O(n)</strong>，空间复杂度为<strong>O(1)</strong> 。</p><h3 id="多个关键词匹配"><a href="#多个关键词匹配" class="headerlink" title="多个关键词匹配"></a>多个关键词匹配</h3><h3 id="如果多个关键词匹配呢"><a href="#如果多个关键词匹配呢" class="headerlink" title="如果多个关键词匹配呢"></a>如果多个关键词匹配呢</h3><p>需要考虑关键词命中的位置，复杂度上升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; keywords = Arrays.asList(<span class="string">"南京"</span>, <span class="string">"皇后大道"</span>, <span class="string">"南京大学"</span>);</span><br><span class="line">String content = <span class="string">"南京市鼓楼区皇后大道22号南京大学北门"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[content.length()];</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">for</span> (String keyword : keywords) &#123;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; content.length() &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((index = content.indexOf(keyword, start)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      indexes[index] = <span class="number">1</span>;</span><br><span class="line">      start += index;</span><br><span class="line">      indexes[index + keyword.length()] = <span class="number">1</span>;</span><br><span class="line">      start += keyword.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; indexes.length; k++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (indexes[k] == <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(content.substring(start, k));</span><br><span class="line">    start = k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start &lt; content.length()) &#123;</span><br><span class="line">  System.out.println(content.substring(start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">南京</span><br><span class="line">市鼓楼区</span><br><span class="line">皇后大道</span><br><span class="line"><span class="number">22</span>号</span><br><span class="line">南京大学</span><br><span class="line">北门</span><br></pre></td></tr></table></figure><p>匹配的时间复杂度为<strong>O(n*m)</strong>，空间复杂度为<strong>O(n)</strong> 。其中n为待匹配的字符串长度，m为关键词个数。</p><h3 id="如果关键词之间有包含关系呢"><a href="#如果关键词之间有包含关系呢" class="headerlink" title="如果关键词之间有包含关系呢"></a>如果关键词之间有包含关系呢</h3><p>需要考虑最长匹配，复杂度进一步上升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; keywords = Arrays.asList(<span class="string">"南京"</span>, <span class="string">"南京市"</span>, <span class="string">"南京大学"</span>, <span class="string">"南大"</span>);</span><br><span class="line"><span class="comment">// emmm，好复杂</span></span><br></pre></td></tr></table></figure><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li>每个关键词匹配是都需要遍历一遍待匹配的字符串</li><li>每次匹配都是独立的，匹配结果需要存储以便进一步处理</li></ul><p>如何解决呢？</p><h2 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树/Trie"></a>前缀树/Trie</h2><p>一种用于字符串匹配的高效数据结构，可实现前缀压缩和线性匹配。</p><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/Trie_example.png" title="Trie_example"><p>图中有8个键，分别为”A”, “to”, “tea”, “ted”, “ten”, “i”, “in” 以及 “inn”。其中的数字对应了每个键对应的值。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>精确匹配</li><li>前缀匹配</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>三数组Trie</li><li>二数组Trie</li></ul><h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(k*m)</li></ul><p>空间换时间。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ol><li>Wiki百科：<a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Trie</a></li><li>Trie在线可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/Trie.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Trie.html</a></li><li>Trie原理到实现：<a href="https://linux.thai.net/~thep/datrie/datrie.html" target="_blank" rel="noopener">https://linux.thai.net/~thep/datrie/datrie.html</a></li><li>从Trie树谈到后缀树：<a href="https://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6897097</a></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果要识别出一个字符串中所有的子串怎么办？还是需要维护匹配状态？emmm….</p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>Aho-Corasick自动机或者算法，简称AC自动机，通过将模式串预处理为确定有限状态自动机，扫描文本一遍就能结束。其复杂度为O(n)，即与模式串的数量和长度无关。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>自动机按照文本字符顺序，接受字符，并发生状态转移。这些状态缓存了“按照字符转移成功（但不是模式串的结尾）”、“按照字符转移成功（是模式串的结尾）”、“按照字符转移失败”三种情况下的跳转与输出情况，因而降低了复杂度。</p><p>AC算法中有三个核心函数，分别是：</p><ul><li>success; 成功转移到另一个状态（也称goto表或success表）</li><li>failure; 不可顺着字符串跳转的话，则跳转到一个特定的节点（也称failure表），从根节点到这个特定的节点的路径恰好是失败前的文本的一部分。</li><li>emits; 命中一个模式串（也称output表）</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以经典的ushers为例，模式串是he/ she/ his /hers，文本为“ushers”。构建的自动机如图：</p><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/ac.png" title="ac"><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>自动机从根节点0出发</p><ol><li>首先尝试按success表转移（图中实线）。按照文本的指示转移，也就是接收一个u。此时success表中并没有相应路线，转移失败。</li><li>失败了则按照failure表回去（图中虚线）。按照文本指示，这次接收一个s，转移到状态3。</li><li>成功了继续按success表转移，直到失败跳转步骤2，或者遇到output表中标明的“可输出状态”（图中红色状态）。此时输出匹配到的模式串，然后将此状态视作普通的状态继续转移。</li></ol><p>算法高效之处在于，当自动机接受了“ushe”之后，再接受一个r会导致无法按照success表转移，此时自动机会聪明地按照failure表转移到2号状态，并经过几次转移后输出“hers”。来到2号状态的路不止一条，从根节点一路往下，“h→e”也可以到达。而这个“he”恰好是“ushe”的结尾，状态机就仿佛是压根就没失败过（没有接受r），也没有接受过中间的字符“us”，直接就从初始状态按照“he”的路径走过来一样（到达同一节点，状态完全相同）。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul><li>多模式匹配</li><li>字典分词(最长分词)</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>基于双数组Trie的实现</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>目前我们主要使用AC自动机来实现基于字典的最长分词。比如下面这个地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">南京市鼓楼区皇后大道22号南京大学</span><br></pre></td></tr></table></figure><p>现在字典中包含”南京市”、”鼓楼区”和”号”关键词，则采用最长分词，可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">南京市 鼓楼区 皇后大道22 号 南京大学</span><br></pre></td></tr></table></figure><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h3><ol><li>Wiki百科：<a href="https://en.wikipedia.org/wiki/Aho-Corasick_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Aho-Corasick_algorithm</a></li><li>Aho-Corasick算法的Java实现与分析：<a href="http://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html" target="_blank" rel="noopener">http://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html</a></li><li>Aho Corasick自动机结合DoubleArrayTrie极速多模式匹配：<a href="http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html" target="_blank" rel="noopener">http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html</a></li></ol><h2 id="几种字符串匹配对比"><a href="#几种字符串匹配对比" class="headerlink" title="几种字符串匹配对比"></a>几种字符串匹配对比</h2><table><thead><tr><th>方法</th><th>单模式</th><th>多模式</th></tr></thead><tbody><tr><td>简单字符串匹配</td><td>支持，速度慢</td><td>支持，太复杂</td></tr><tr><td>Trie</td><td>支持，速度快</td><td>支持，需要额外编码</td></tr><tr><td>Aho-Corasick</td><td>支持，速度快</td><td>完全支持</td></tr></tbody></table><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>测试条件：给定63万个字符串，从中随机抽取100个字符串作为待识别字符串，测试完成100个字符串匹配需要多长时间？</p><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/match_test.png" title="match_test"><h2 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h2><p>时间地址处理过程中经常会遇到这样的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">江苏省南京市江苏省南京市鼓楼区皇后大道22号南京大学</span><br></pre></td></tr></table></figure><p>那现在如何处理以将这样的地址规范化成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">江苏省南京市鼓楼区皇后大道22号南京大学</span><br></pre></td></tr></table></figure><p>这样的问题，可以抽象为：</p><blockquote><p>给定一个字符串L，如果子串R(至少包含一个字符)在L中至少出现两次，则称R是L的重复子串。而其中的最长的重复子串，称为最长重复子串。解决这样的问题，可以称为Longest Repeat Subsequence。</p></blockquote><p>比如上例中的最长重复子串是”江苏省南京市”。</p><h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>直接子串和子串比较，查看所有字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestRepeatSubsequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lenOfSubsequence</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">            System.out.println(s.substring(i - count, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                len = lenOfSubsequence(s, i, j, maxLen);</span><br><span class="line">                <span class="keyword">if</span> (maxLen &lt; len) &#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String address = <span class="string">"江苏省南京市江苏省南京市鼓楼区皇后大道22号南京大学"</span>;</span><br><span class="line">        System.out.println(nativeMethod(address));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的话时间复杂度$O(n^3)$，复杂度有点高。</p><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>后缀：指从某个位置 $i$ 开始到整个字符串末尾结束的一个子串。字符串 $r$ 中从 $i$ 个字符开始的后缀表示为$suffix(i)$</li><li>字符串大小：大小是指”字典顺序”</li><li>后缀数组：一个存储了指定字符串所有后缀的大小为 $n$ 一维数组 $S_A$，并且其中的所有后缀按照字符串大小排序。$S_A[i] &lt; S_A[i+1] , 1 \leq i \leq n$</li></ul><p>比如<code>banana</code>字符串的后缀数组为：</p><ul><li>a[0]: a</li><li>a[1]: ana</li><li>a[2]: anana</li><li>a[3]: banana</li><li>a[4]: na</li><li>a[5]: nana</li></ul><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>通过一步预处理，降低了找寻具有相同前缀的子串的复杂度。现在只需要计算后缀数组中相邻两个后缀子串的公共前缀长度。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>还是以上面例子来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">suffixArray</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Suffix&gt; suffixes = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        suffixes.add(<span class="keyword">new</span> Suffix(i, s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    Suffix pre = suffixes.pollFirst();</span><br><span class="line">    <span class="keyword">for</span> (Suffix suffix : suffixes) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = lenOfSubsequence(s, pre.index, suffix.index, max);</span><br><span class="line">        <span class="keyword">if</span> (max &lt; len) &#123;</span><br><span class="line">            max = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Suffix</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Suffix</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Suffix</span><span class="params">(<span class="keyword">int</span> index, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">subsequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.substring(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subsequence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Suffix o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = index;</span><br><span class="line">        <span class="keyword">int</span> j = o.index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; data.length() &amp;&amp; j &lt; data.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.charAt(i) &gt; data.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.charAt(i) &lt; data.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>遍历原始字符串，得到后缀数组，时间复杂度为 $O(n)$</li><li>后缀数组排序，由于TreeSet底层使用TreeMap实现，其通过Red-Black Tree来实现，所以每插入一个元素的时间复杂度为 $O(logn)$ ，因此整个排序过程需要 $O(nlogn)$ </li><li>计算最长重复子串，遍历后缀数组，每两个相邻后缀的计算，时间复杂度为 $O(n^2)$</li></ul><p>总体时间复杂度为$O(n) + O(nlogn) + O(n^2) = \Theta(n^2)$。但增加了额外的存储，空间复杂度为$\Theta(n)$ 。还是空间换时间。</p><h3 id="更多-2"><a href="#更多-2" class="headerlink" title="更多"></a>更多</h3><ol><li>从Trie树谈到后缀树：<a href="https://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6897097</a></li></ol><h2 id="字符串之间的相似性"><a href="#字符串之间的相似性" class="headerlink" title="字符串之间的相似性"></a>字符串之间的相似性</h2><p>考虑这样一个问题：<br>$$<br>“南京大学”  \simeq  “南大” ?<br>$$</p><p>如何衡量两个字符串之间的相似性？</p><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>通过定义“距离”的概念来对字符串进行相似性度量。距离度量应该满足以下几个条件：</p><ol><li>对称性，即 $d(A, B) = d(B, A)$</li><li>非负性，即 $\forall A\forall B, d(A, B) \ge 0$</li><li>一致性，即 $A = B\Leftrightarrow d(A, B) = 0$</li><li>三角不等式，即 $d(A, C) \le d(A, B) + d(B, C)$</li></ol><p>比如明氏距离(Minkowski distance)一种比较常用的距离：<br>$$<br>L_p(x_i, x_j) = \bigg(\sum_{l=1}^{n}|x_i^{(l)} - x_j^{(l)}|^p \bigg)^{\frac {1} {p}}, p \ge 1<br>$$</p><ul><li>当p=1时，为曼哈顿距离</li><li>当p=2时，为欧几里得距离</li><li>当p=$\infty$时，为切比雪夫距离</li></ul><h3 id="字符串相似性"><a href="#字符串相似性" class="headerlink" title="字符串相似性"></a>字符串相似性</h3><ul><li>编辑距离/扩展编辑距离</li><li>汉明距离</li><li>最长公共子序列(LCS)</li></ul><p>这边着重介绍一下编辑距离和最长公共子序列，汉明距离主要应用于长度相同的序列比较，局限性较大。</p><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>针对两个字符串的差异程度的量化，方式是通过至少需要多少次处理才能将一个字符串变为另一个字符串。可接受的处理包括：</p><ul><li>删除某个字符</li><li>插入某个字符</li><li>替换某个字符</li></ul><p>通常会有一者作为标准字符串，另一者作为可能出错的字符串，两种进行距离计算，得出可能出错的字符串是否是某个标准字符串。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>比如<code>南大</code>和<code>南京大学</code>两者的编辑距离为2：</p><ol><li>南大 $\rightarrow$ 南<strong>京</strong>大（插入<strong>京</strong>）</li><li>南京大 $\rightarrow$ 南京大<strong>学</strong>（插入<strong>学</strong>）</li></ol><p>另一个经典实例是<code>kitten</code>和<code>sitting</code>的编辑距离，它们之间的距离是3：</p><ol><li><strong>k</strong>itten $\rightarrow$ <strong>s</strong>itten (将k替换为s)</li><li>sitt<strong>e</strong>n $\rightarrow$ sitt<strong>i</strong>n (将e替换为i)</li><li>sittin $\rightarrow$ sittin<strong>g</strong> (最后插入g)</li></ol><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>这是个动态规划问题，其转移方程定义：<br>$$<br>\begin{eqnarray} D(A_i, B_j) = \begin{cases}<br>D(A_{i-1},  B_{j-1}) &amp; if \quad a_i = b_j \<br>min(D(A_{i-1}, B_j) + 1,  D(A_i, B_{j-1}) + 1, D(A_{i-1},  B_{j-1}) + 1) &amp; if \quad a_i \neq b_j \<br>max(i, j) &amp; if \quad min(i, j) = 0 \<br>\end{cases}\end{eqnarray}<br>$$<br><em>其中$A_i$表示$A$的前 $i$个字符组成的字符串，$a_i$表示$A$中第 $i$个字符，$B_j$和 $b_j$同理。</em></p><p>转换为语言描述：</p><ol><li>当$a_i = b_j$时，$D(A_i, B_j) = D(A_{i-1}, B_{j-1})$。比如”abx”和”acx”的编辑距离等于”ab”和”ac”的编辑距离</li><li>当$a_i \neq b_j$时，$D(A_i, B_j)$等于以下三者的最小值：<ul><li>$D(A_{i-1}, B_j) + 1$（删除$a_i$），比如”abx”和”acy”的编辑距离等于”ab”和”acy”的编辑距离 + 1</li><li>$D(A_{i}, B_{j-1}) + 1$（插入$b_i$），比如”abx”和”acy”的编辑距离等于”abxy”和”acy”的编辑距离 + 1</li><li>$D(A_{i-1}, B_{j-1}) + 1$（将$a_i$替换为$b_j$），比如”abx”和”acy”的编辑距离等于”aby”和”acy”的编辑距离 + 1</li></ul></li><li>当$A$字符串为空，表示将$A$需要插入$b_1 - b_j$字符，所以此时编辑距离为$j$，结束</li><li>当$B$字符串为空，表示需要将$A$中$a_1 - a_i$字符全部删除，所以此时编辑距离为$i$，结束</li></ol><p>这边有一个优化点可以只通过一维数组保存历史值，降低空间复杂度。</p><h3 id="相似度量"><a href="#相似度量" class="headerlink" title="相似度量"></a>相似度量</h3><p>编辑距离衡量的是差异性，如何转换为相似程度呢？<br>$$<br>S(A, B)=1 - \frac {D(A, B)} {max(|A|, |B|)}<br>$$<br><em>其中$D(A, B)$表示字符串A和字符串B的编辑距离，$|A|$和$|B|$分别表示字符串A和字符串B的长度。</em></p><p>比如<code>南京大学</code>和<code>南大</code>两者的根据编辑距离计算得到的相似度为<br>$$<br>S(“南京大学”, “南大”) = 1 - \frac {2} {max(4, 2)} = 1 - \frac {2} {4} = 0.5<br>$$</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>模糊匹配</li><li>拼写检查</li></ul><h3 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h3><ul><li>Damerau-Levenshtein 距离：主要是增加了<strong>相邻字符交换</strong>这样一个操作，应为在实际情况中人们输入时前后两个字符顺序被输错的情况很常见。但个人认为这个在中文输入情况下比较少见。</li><li>Weighted-Levenshtein 距离：即赋予每个动作一定的权重，比如降低插入权重，提高替换权重。</li></ul><h3 id="更多-3"><a href="#更多-3" class="headerlink" title="更多"></a>更多</h3><ol><li>Wiki百科：<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Edit_distance</a></li><li>编辑距离实现及优化：<a href="http://www.dreamxu.com/books/dsa/dp/edit-distance.html" target="_blank" rel="noopener">http://www.dreamxu.com/books/dsa/dp/edit-distance.html</a></li><li>文本相似度量方法(1)：<a href="http://www.zmonster.me/2015/11/15/text-similarity-survey.html" target="_blank" rel="noopener">http://www.zmonster.me/2015/11/15/text-similarity-survey.html</a></li><li>文本相似度量方法(2)：<a href="http://www.zmonster.me/2016/03/31/text-similarity-character-based-1.html" target="_blank" rel="noopener">http://www.zmonster.me/2016/03/31/text-similarity-character-based-1.html</a></li></ol><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><p>对给定序列$A$和$B$，满足以下条件的一个序列$C$被称为$A$和$B$的公共子序列：</p><ol><li>$C$中的每一个元素都对应$A$和$B$中的一个元素</li><li>从$C$中挑选两个元素$C_i$和$C_j$，其中$i$和$j$表示这两个元素在$C$中的序号(从左到右)，假设这两个元素分别对应$A_m$和$A_n$，那么有$(i-j)\cdot(n-m) \gt 0$，在$B$中对应的两个元素同理。即$C$中任意两个元素对应到$A$和$B$中其序号都应该是递增的</li></ol><p>比如说$A$=”南京市人民政府”，$B$=”南京人民政府”，那以下都是$A$和$B$的子序列：</p><ul><li>“南京”</li><li>“人民政府”</li></ul><p>其中长度最大的即所谓的最长公共子序列。比如上面例子中的最长的”人民政府”。可以这样认为，如果$A$和$B$的最长公共子序列越长，$A$和$B$就越相似。</p><p>计算时两个字符或者序列的地位是等价的。</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>这是个经典的动态规划问题，其转移方程定义为：<br>$$<br>\begin{eqnarray} LCS(A_i, B_j) = \begin{cases}<br>\emptyset &amp; if \quad i=0 \quad or \quad j=0 \<br>LCS(A_{i-1}, B_{j-1}) + a_i &amp; if \quad a_i = b_j \<br>longest(LCS(A_i, B_{j-1}), LCS(A_{i-1}, B_j)) &amp; if \quad a_i \neq b_j\<br>\end{cases}\end{eqnarray}<br>$$<br><em>其中$A_i$表示$A$的前 $i$个字符组成的字符串，$a_i$表示$A$中第 $i$个字符，$B_j$和 $b_j$同理。</em></p><p>转为语言描述就是：</p><ol><li>当$a_i = b_i$时，$LCS(A_i, B_j) = LCS(A_{i-1}, B_{j-1})$。比如”abc”和”axy”的LCS等于”bc”和”xy”的LCS + “a”</li><li>当$a_i \neq b_i$时，$LCS(A_i, B_j)$等于以下两者之间的最长的：<ul><li>将$a_i$去掉，使用剩下的部分和$B$一起计算LCS</li><li>将$b_j$去掉，使用剩下的部分和$A$一起计算LCS</li></ul></li><li>当$A$字符串或者$B$字符串没有剩余字符时，返回空字符串，结束</li></ol><h3 id="相似度量-1"><a href="#相似度量-1" class="headerlink" title="相似度量"></a>相似度量</h3><p>$$<br>S(A, B) = \frac {2 \cdot |LCS(A, B)|} {|A| + |B|}<br>$$</p><p><em>其中$|LCS(A, B)|$表示最长公共子序列的长度，$|A|$和$|B|$分别表示$A$和$B$字符串的长度。</em></p><p>比如<code>南京市人民政府</code>和<code>南京人民政府</code>两者的根据LCS计算得到的相似度为<br>$$<br>S(“南京市人民政府”，”南京人民政府”) = \frac {2 \cdot 4} {7 + 6}=0.62<br>$$</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>版本控制</li></ul><h3 id="更多-4"><a href="#更多-4" class="headerlink" title="更多"></a>更多</h3><ol><li>Wiki百科：<a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Longest_common_subsequence_problem</a></li><li>文本相似度量方法(1)：<a href="http://www.zmonster.me/2016/03/31/text-similarity-survey.html" target="_blank" rel="noopener">http://www.zmonster.me/2015/11/15/text-similarity-survey.html</a></li><li>文本相似度量方法(2)：<a href="http://www.zmonster.me/2016/03/31/text-similarity-character-based-1.html" target="_blank" rel="noopener">http://www.zmonster.me/2016/03/31/text-similarity-character-based-1.html</a></li></ol><h2 id="字符串相似性使用效果"><a href="#字符串相似性使用效果" class="headerlink" title="字符串相似性使用效果"></a>字符串相似性使用效果</h2><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>在地址库中，我们需要对切分出的兴趣点数据进行二次校验，以尽量保证地址的归一化效果。比如以下两个地址</p><ul><li>“南京市建邺区烽火大厦”</li><li>“南京市建邺区烽火科技大厦”</li></ul><p>经过切分处理后得到：</p><ul><li>“南京市” “建邺区” “烽火大厦”</li><li>“南京市” “建邺区” “烽火科技大厦”</li></ul><p>如果不进行兴趣点校验则，两个地址在机器看来不一样。通过校验后(假设数据中”烽火科技大厦”出现次数高于”烽火大厦”)，则有：</p><ul><li>“南京市” “建邺区” “烽火科技大厦”</li><li>“南京市” “建邺区” “烽火科技大厦”</li></ul><h3 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h3><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/POI_check_test.png" title="POI_check_test"><h2 id="逻辑判断太复杂"><a href="#逻辑判断太复杂" class="headerlink" title="逻辑判断太复杂"></a>逻辑判断太复杂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition12 &amp;&amp; condition3) &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition4 || condition5) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition6 &amp;&amp; condition7 || condition8) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition9) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition10) &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition11) &#123;</span><br><span class="line">        ....</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition12 &amp;&amp; condition13) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition134) &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/wtf.png" title="wtf"><p>其实控制语句描述的是状态如何迁移，需要明确哪些是状态，迁移条件是什么。而态机就是用来描述状态及其迁移状态的结构，其中有限状态机使用最广。</p><h2 id="有限状态机-FSM-FSA"><a href="#有限状态机-FSM-FSA" class="headerlink" title="有限状态机(FSM/FSA)"></a>有限状态机(FSM/FSA)</h2><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/DFAexample.png" title="DFAexample"><p>这是个很简单的状态机，你知道它表达的是什么吗？</p><p> <span style="background-color:#252525;">其实它表示一个含有偶数个0的二进制数。</span> </p><p>一般状态机由以下五个要素定义：</p><ul><li>$\Sigma$ 表示状态机接受的输入符号集</li><li>$S$ 表示一个有限非空的状态集</li><li>$S_0$ 表示初始状态，$S_0 \in S$</li><li>$\delta$ 表示状态转换函数，$\delta: S \times \Sigma \rightarrow S$</li><li>$F$ 表示可终结状态集(可能为空)，$F \subset S$</li></ul><p>你能说出上图的五要素吗？</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>实现不复杂，一般需要定义<strong>state</strong>和<strong>transition</strong>。核心在于状态之间的迁移实现，比如Map或者Array。</p><h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>地址库中需要对规范化的地址进行检查，以便满足业务要求。比如要求实现以下条件约束的检查：</p><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/address_model.png" title="address_model"><p>如果使用控制语句实现，就会很复杂，且如果业务需求变化，整个逻辑就需要调整，代码需要重新编译，容易出错。因此，我们通过FSA抽象出可配置的检查：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--states描述了当前模型中包含的各种状态。id表示状态唯一代号，不能够重复；name表示状态名称；isTerminated表示该状态是否是可总结的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">states</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"root"</span> <span class="attr">name</span>=<span class="string">"中国"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L1"</span> <span class="attr">name</span>=<span class="string">"省"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L2"</span> <span class="attr">name</span>=<span class="string">"市"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L3"</span> <span class="attr">name</span>=<span class="string">"区"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L4"</span> <span class="attr">name</span>=<span class="string">"街道"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L5"</span> <span class="attr">name</span>=<span class="string">"社区"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L6"</span> <span class="attr">name</span>=<span class="string">"路"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L7"</span> <span class="attr">name</span>=<span class="string">"号"</span> <span class="attr">isTerminated</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L8"</span> <span class="attr">name</span>=<span class="string">"小区"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L9"</span> <span class="attr">name</span>=<span class="string">"楼栋"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L10"</span> <span class="attr">name</span>=<span class="string">"单元"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L11"</span> <span class="attr">name</span>=<span class="string">"楼层"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">state</span> <span class="attr">id</span>=<span class="string">"L12"</span> <span class="attr">name</span>=<span class="string">"室"</span> <span class="attr">isTerminated</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">states</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--transitions描述了各个状态之间如何转移。from表示当前状态；to表示转移后的状态；</span></span><br><span class="line"><span class="comment">    when表示如何或者什么时候转移，目前表示对应等级元素存在时--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transitions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"root"</span> <span class="attr">to</span>=<span class="string">"L1"</span> <span class="attr">when</span>=<span class="string">"A"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L1"</span> <span class="attr">to</span>=<span class="string">"L2"</span> <span class="attr">when</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L2"</span> <span class="attr">to</span>=<span class="string">"L3"</span> <span class="attr">when</span>=<span class="string">"C"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L2"</span> <span class="attr">to</span>=<span class="string">"L4"</span> <span class="attr">when</span>=<span class="string">"D"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L2"</span> <span class="attr">to</span>=<span class="string">"L6"</span> <span class="attr">when</span>=<span class="string">"F"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L3"</span> <span class="attr">to</span>=<span class="string">"L4"</span> <span class="attr">when</span>=<span class="string">"D"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L3"</span> <span class="attr">to</span>=<span class="string">"L5"</span> <span class="attr">when</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L3"</span> <span class="attr">to</span>=<span class="string">"L6"</span> <span class="attr">when</span>=<span class="string">"F"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L3"</span> <span class="attr">to</span>=<span class="string">"L8"</span> <span class="attr">when</span>=<span class="string">"H"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L4"</span> <span class="attr">to</span>=<span class="string">"L5"</span> <span class="attr">when</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L4"</span> <span class="attr">to</span>=<span class="string">"L6"</span> <span class="attr">when</span>=<span class="string">"F"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L4"</span> <span class="attr">to</span>=<span class="string">"L8"</span> <span class="attr">when</span>=<span class="string">"H"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L5"</span> <span class="attr">to</span>=<span class="string">"L6"</span> <span class="attr">when</span>=<span class="string">"F"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L5"</span> <span class="attr">to</span>=<span class="string">"L7"</span> <span class="attr">when</span>=<span class="string">"G"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L5"</span> <span class="attr">to</span>=<span class="string">"L8"</span> <span class="attr">when</span>=<span class="string">"H"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L6"</span> <span class="attr">to</span>=<span class="string">"L7"</span> <span class="attr">when</span>=<span class="string">"G"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L6"</span> <span class="attr">to</span>=<span class="string">"L8"</span> <span class="attr">when</span>=<span class="string">"H"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L7"</span> <span class="attr">to</span>=<span class="string">"L8"</span> <span class="attr">when</span>=<span class="string">"H"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L7"</span> <span class="attr">to</span>=<span class="string">"L9"</span> <span class="attr">when</span>=<span class="string">"J"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L8"</span> <span class="attr">to</span>=<span class="string">"L9"</span> <span class="attr">when</span>=<span class="string">"J"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L8"</span> <span class="attr">to</span>=<span class="string">"L12"</span> <span class="attr">when</span>=<span class="string">"M"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L9"</span> <span class="attr">to</span>=<span class="string">"L10"</span> <span class="attr">when</span>=<span class="string">"K"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L9"</span> <span class="attr">to</span>=<span class="string">"L11"</span> <span class="attr">when</span>=<span class="string">"L"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L9"</span> <span class="attr">to</span>=<span class="string">"L12"</span> <span class="attr">when</span>=<span class="string">"M"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L10"</span> <span class="attr">to</span>=<span class="string">"L11"</span> <span class="attr">when</span>=<span class="string">"L"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L10"</span> <span class="attr">to</span>=<span class="string">"L12"</span> <span class="attr">when</span>=<span class="string">"M"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">from</span>=<span class="string">"L11"</span> <span class="attr">to</span>=<span class="string">"L12"</span> <span class="attr">when</span>=<span class="string">"M"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transitions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更多-5"><a href="#更多-5" class="headerlink" title="更多"></a>更多</h3><ol><li>Wiki百科: <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Finite-state_machine</a></li></ol><h2 id="Java中的位运算"><a href="#Java中的位运算" class="headerlink" title="Java中的位运算"></a>Java中的位运算</h2><p>Java中很多人使用过最小粒度的内存操作也就是<strong>byte[]</strong>，很少使用甚至没有听说过位运算。其实，一些场景下，合理使用，可以极大的简化代码和提升性能。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>&amp;：与</li><li>|：或</li><li>~：非</li><li>^：异或</li><li>&gt;&gt;：算术右移</li><li>&gt;&gt;&gt;：逻辑右移</li><li>&lt;&lt;：算术左移/逻辑左移</li><li>循环左移/右移(无单独运算符)</li></ul><p>你能说出算术和逻辑的区别吗？</p><p>另外，我们还需要知道在Java中，byte, short, int, long, float, double都是有符号的，且负整型数值采用补码表示，浮点类型采用<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754</a>标准(更多内容，可以阅读《<a href="https://book.douban.com/subject/1230413" target="_blank" rel="noopener">深入理解计算机系统</a>》)。算术和逻辑的位移操作在于对符合位的处理：</p><ol><li>算术左移/逻辑左移：依次左移一位，尾部补0。</li><li>算术右移：依次右移一位，尾部丢失，符号位复制一位</li><li>逻辑右移：依次右移一位，尾部丢失，最高位补0</li></ol><p>下面这些运算的结果是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-~<span class="number">1</span>;</span><br><span class="line">~-<span class="number">1</span>;</span><br><span class="line">~<span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">(n &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">(-<span class="number">1</span> ^ <span class="number">23</span>) &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="number">1</span> ^ <span class="number">2</span> ^ <span class="number">1</span>;</span><br><span class="line">(<span class="number">2</span> + <span class="number">4</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">Integer.MIN_VALUE &lt;&lt; <span class="number">1</span>;</span><br><span class="line">Integer.MIN_VALUE &gt;&gt; <span class="number">31</span>;</span><br><span class="line">Integer.MIN_VALUE &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">Integer.MAX_VALUE &lt;&lt; <span class="number">1</span>;</span><br><span class="line">Integer.MAX_VALUE &lt;&lt; <span class="number">31</span>;</span><br><span class="line">-<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">-<span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Long/Integer等包装类中有不少方法涉及到位操作，可以细细品读。此外JDK1.7以后引入了二进制表示以及数值类型可以加入下划线提高可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary = <span class="number">0b1010_1010_1010</span>;</span><br></pre></td></tr></table></figure><h3 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h3><p>一般情况下可以利用byte，short，int和long加上位运算来进行少量信息的计算，但是当需要很多位来存储信息时，比如Bitmap，BloomFilter中。虽然可以通过多个int或者long来存储，但Java中提供了更为方便的<strong>BitSet</strong>。</p><img src="/talk-about-some-data-structures-and-algorithms-used-in-address-standardization/bitset.png" title="bitset"><p>一般可以利用它来大幅度提高内存使用效率，比如下面这个题目：</p><blockquote><p>有一千万个随机数，其取值范围为1到1亿之间。现在要求写一种算法，将1到1亿之间没有在这一千万随机数中的数找出来？</p></blockquote><p>如果一个随机数使用一个int(4bytes)来存储的话，那么需要<br>$$<br>\frac {4 \times 10000000} {1024 \times 1024} \approx 38.15 MB<br>$$<br>如果使用BitSet的话，我们需要1亿个bit，那么需要<br>$$<br>\frac {100000000} {8 \times 1024 \times 1024} \approx 11.92MB<br>$$<br>内存使用减少3倍。</p><p>那么，你知道接下来该如何实现来解决该题目呢？</p><h3 id="实际应用-2"><a href="#实际应用-2" class="headerlink" title="实际应用"></a>实际应用</h3><p>地址库中有一个补全环节，需要提取已切分地址中是否存在一些可用于补全的信息，考虑以下地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">南京市 建邺区 沙洲街道 云龙山路 88号 烽火科技大厦</span><br></pre></td></tr></table></figure><p>这种地址存在一些可用的补全信息比如：</p><ul><li>建邺区+沙洲街道+云龙山路</li><li>云龙山路+88号+烽火科技大厦</li></ul><p>这些信息可以用于补全下面的地址：</p><ul><li>南京市建邺区烽火科技大厦  $\rightarrow$ 南京市建邺区沙洲街道云龙山路88号烽火科技大厦</li><li>南京市云龙山路88号烽火科技大厦 $\rightarrow$ 南京市建邺区沙洲街道云龙山路88号烽火科技大厦</li></ul><p>那如何来识别一个地址中是否存在可用的补全信息呢？进一步讲如何判断这些补全信息对某个地址来说是否有用呢？如果采用简单的if…else…的话，就会面临语句太复杂的问题，且性能上存在隐患。这里的做法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; addresses = Arrays.asList(<span class="string">"江苏省"</span>, <span class="string">"南京市"</span>, <span class="string">"建邺区"</span>, <span class="string">"沙洲街道"</span>, <span class="string">""</span>, <span class="string">"云龙山路"</span>, <span class="string">"88号"</span>, <span class="string">"烽火科技大厦"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String address: addresses) &#123;</span><br><span class="line">  mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!address.isEmpty()) &#123;</span><br><span class="line">    mask |= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(mask); <span class="comment">// 你知道mask等于多少吗？</span></span><br></pre></td></tr></table></figure><p>由于实际情况中省市区已经可以通过字典进行补全，可以省略省市部分，这样降低了可能的值域范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask &amp;= <span class="number">0x1F</span>;</span><br><span class="line">System.out.println(mask); <span class="comment">// 现在mask等于多少？</span></span><br></pre></td></tr></table></figure><p>这样，地址可以转换为一个整数来表示。通过枚举各种能够提供有用补全信息的情况，可以获取相应的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 31: 即二进制11111，表示街道、社区、路、号、小区均有值</span></span><br><span class="line"><span class="comment">// 30: 即二进制11110，表示街道、社区、路、号均有值</span></span><br><span class="line"><span class="comment">// 29: 即二进制11101，表示街道、社区、路、小区均有值</span></span><br><span class="line"><span class="comment">// 28: 即二进制11100，表示表示街道、社区、路均有值</span></span><br><span class="line"><span class="comment">// 25: 即二进制11001，表示街道、社区、小区均有值</span></span><br><span class="line"><span class="comment">// 24: 即二进制11000，表示街道、社区均有值</span></span><br><span class="line"><span class="comment">// 23: 即二进制10111，表示街道、路、号、小区均有值</span></span><br><span class="line"><span class="comment">// 22: 即二进制10110，表示街道、路、号均有值</span></span><br><span class="line"><span class="comment">// 21: 即二进制10101，表示街道、路、小区均有值</span></span><br><span class="line"><span class="comment">// 20: 即二进制10100，表示街道、路均有值</span></span><br><span class="line"><span class="comment">// 17: 即二进制10001，表示街道、小区均有值</span></span><br><span class="line"><span class="comment">// 15: 即二进制01111，表示社区、路、号、小区均有值</span></span><br><span class="line"><span class="comment">// 14: 即二进制01110，表示社区、路、号均有值</span></span><br><span class="line"><span class="comment">// 13: 即二进制01101，表示社区、路、小区均有值</span></span><br><span class="line"><span class="comment">// 12: 即二进制01100，表示社区、路均有值</span></span><br><span class="line"><span class="comment">// 9: 即二进制01001，表示社区、小区均有值</span></span><br><span class="line"><span class="comment">// 7: 即二进制00111，表示路、号、小区均有值</span></span><br><span class="line"><span class="comment">// 5: 即二进制00101，表示路、小区均有值</span></span><br></pre></td></tr></table></figure><p>现在可以使用前面介绍的BitSet来存储这些信息，这里只需要32bit(即一个int)就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BitSet filter = <span class="keyword">new</span> BitSet(<span class="number">32</span>); <span class="comment">// 目前Java实现实际需要一个long型来存储</span></span><br><span class="line">filter.set(<span class="number">28</span>, <span class="number">32</span>);</span><br><span class="line">filter.set(<span class="number">20</span>, <span class="number">26</span>);</span><br><span class="line">filter.set(<span class="number">17</span>);</span><br><span class="line">filter.set(<span class="number">12</span>, <span class="number">16</span>);</span><br><span class="line">filter.set(<span class="number">9</span>);</span><br><span class="line">filter.set(<span class="number">7</span>);</span><br><span class="line">filter.set(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(filter.get(mask)); <span class="comment">// true or false?</span></span><br></pre></td></tr></table></figure><p>现在有一个新地址，可以这样来判断，现有补全信息是否可以补全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 南京市建邺区烽火科技大厦 -&gt; 10001 = 17</span></span><br><span class="line"><span class="comment">// 南京市云龙山路88号烽火科技大厦 -&gt; 00111 = 7</span></span><br><span class="line">System.out.println((mask &amp; <span class="number">17</span>) &gt; <span class="number">0</span>); <span class="comment">// true or false?</span></span><br><span class="line">System.out.println((mask &amp; <span class="number">7</span>) &gt; <span class="number">0</span>); <span class="comment">// true or false?</span></span><br><span class="line">System.out.println((<span class="number">24</span> &amp; <span class="number">7</span>) &gt; <span class="number">0</span>); <span class="comment">// true or false?</span></span><br></pre></td></tr></table></figure><h3 id="更多-6"><a href="#更多-6" class="headerlink" title="更多"></a>更多</h3><p>如果你想深入了解一下位的神操作，建议你读一下《Hacker’s Delight》，中文名《算法心得：高效算法的奥秘》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地址标准化在数据处理过程中算是一个比较常见的需求，这里说说个人在地址标准化过程中的一些实现思路和算法，抛砖引玉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="engineering" scheme="https://johntse.dev/categories/engineering/"/>
    
    
      <category term="algorithm" scheme="https://johntse.dev/tags/algorithm/"/>
    
      <category term="data structure" scheme="https://johntse.dev/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Bigdata</title>
    <link href="https://johntse.dev/thinking-in-bigdata/"/>
    <id>https://johntse.dev/thinking-in-bigdata/</id>
    <published>2016-10-09T00:44:57.000Z</published>
    <updated>2020-05-10T05:14:12.981Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是本人在接触大数据过程中，对一些原理、概念以及当前常用实现技术的笔记和总结。本人接触大数据不深，实践不多，见识不广，如果错误或者偏颇之处，欢迎斧正。</p><p><em>未完待续</em></p><a id="more"></a><h2 id="一、-引言"><a href="#一、-引言" class="headerlink" title="一、 引言"></a>一、 引言</h2><p>这篇文章是本人在接触大数据过程中，对一些原理、概念以及当前常用实现技术的笔记和总结。本人接触大数据不深，实践不多，见识不广，如果错误或者偏颇之处，欢迎斧正。</p><h2 id="二、-数据"><a href="#二、-数据" class="headerlink" title="二、 数据"></a>二、 数据</h2><p>数据伴随着人类文明出现和发展，同样计算的需求一直存在，从结绳记事到算盘，从差分机到现代计算机的诞生无不是用来更好地处理数据的。然而计算资源始终是有限的，这就决定了计算的过程必定是迭代进行的，中间结果和未使用数据都需要存放在特定的介质上。</p><p>数据存放的介质从竹简到纸张，从磁带到高速缓存，存放的容量和存取速度不断演变。同样由于资源的有限性，在现代计算机上，需要面临容量和速度的取舍。下面是现代计算机的存储体系（冯·洛伊曼体系）：</p><img src="/thinking-in-bigdata/computer_storage.png" title="computer_storage"><p>这里可以看到容量和速度存在<strong>反比</strong>关系。为了提高计算速度，数据存放介质的存取速度当然越快越好，但受容量的限制大部分数据都被存放在存取速度一般或者很慢的介质上，即绝大部分数据往往存放在离CPU较远的地方。而计算时往往需要在那些存取速度较慢的介质上搜索所需要的数据，或者更新数据到这些介质。一方面，这些介质本身访问速度慢；另一方面，其上存储数据量较大，进一步降低了定位数据的速度。</p><p>早期，数据量不大结构简单的情况下，人们简单地使用操作系统的文件系统来管理存储数据的文件，实现数据的管理工作。但随着数据量增大，结构复杂化，一些问题逐渐显现：</p><ul><li>随着数据量增大，如何提高搜索速度</li><li>写入数据时，如何确保写入一定是成功的</li><li>多个人同时操作同一个数据造成的并发控制问题</li><li>相同数据重复存储，更新不一致的问题</li><li>通过程序直接操作数据时，发生异常时，数据状态变得不确定</li><li>数据需要能被所有人看到吗，要不要权限控制</li><li>…</li></ul><p>为了解决这些问题，人们通过构建专门的数据库管理系统(DBMS，在不产生歧义的情况下，下面一律使用”数据库”来代替)来进行数据的管理和维护。同样地，这些系统也随着时代不断演变着。</p><h3 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a>1. 数据存储</h3><blockquote><p>此处直接从关系型数据库说起，感兴趣的可以参考数据库的维基百科词条<a href="https://en.wikipedia.org/wiki/Database" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Database</strong></a></p></blockquote><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>这里得提一下关系型数据库的奠基人英国计算机科学家——<strong>埃德加·科德</strong>(老爷子在2003年4月18日因心脏病去世，<strong>R.I.P</strong>)在上个世纪70年代提出的关系模型以及著名的科德十二定律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 准则0：基本准则。一个关系型数据库系统必须能完全通过它的关系能力来管理数据库</span><br><span class="line">2. 准则1：信息准则。关系数据库的所有信息都应该在逻辑级别上用表中的值这一个方式显式地来表示</span><br><span class="line">3. 准则2：保证访问准则。依靠表名、主码和列名的组合，保证能以逻辑方式访问关系型数据库中的每个数据项</span><br><span class="line">4. 准则3：空值的系统化处理准则。全关系的关系数据库系统支持空值的概念，并用系统化的方法处理空值</span><br><span class="line">5. 准则4：基于关系模型的动态联机数据字典。数据库的描述在逻辑上和普通数据采用同样的表达方式，这样可以使用同样的关系语音进行解释</span><br><span class="line">6. 准则5：统一的数据子语言准则。一个关系数据库系统可以具有几种语言和多种终端访问方式</span><br><span class="line">   但必须有一种语言，它的语句可以表示为严格语法规定和字符串，并能支持以下事项：</span><br><span class="line">    - 数据定义</span><br><span class="line">    - 视图定义</span><br><span class="line">    - 数据操作(交互式或者程序)</span><br><span class="line">    - 完整性约束</span><br><span class="line">    - 认证</span><br><span class="line">    - 事务边界(开始，提交和回滚)</span><br><span class="line">7. 准则6：视图更新准则。所有理论上可能性的视图也应该允许由系统更新</span><br><span class="line">8. 准则7：高级的插入、修改和删除操作。系统应该对各种操作进行查询优化</span><br><span class="line">9. 准则8：数据的物理独立性。无论数据库的数据在存储表示或者存取方法上作任何变化，应用程序和终端活动都保持逻辑上的不变性</span><br><span class="line">10. 准则9：数据的逻辑独立性。当对基本关系进行理论上信息无损变更时，应用程序和终端活动都保持逻辑上的不变性</span><br><span class="line">11. 准则10：数据完整的独立性。关系数据库的完整性约束条件必须是用数据库语言定义并存储在数据字典中</span><br><span class="line">12. 准则11：分布独立性。关系数据库系统在引入分布数据或者数据重新分布时保持逻辑的不变性</span><br><span class="line">13. 准则12：无破坏准则。如果一个关系数据库系统具有一个低级语言，那么这个低级语言不能违背或者绕过完整性准则</span><br></pre></td></tr></table></figure><p>这些准则定义了一个关系型数据库管理系统应该满足什么条件。</p><p>随后，IBM进一步完善他的工作，并促进相关的标准化。其中SQL成为了ANSI和ISO的标准。它是数据库方面最广为人知的概念和工具了，成为了这类数据库的代名词。根据准则，SQL提供了：</p><ul><li><strong>DDL:</strong> 数据定义语言(Data Definition Language)</li><li><strong>DML:</strong> 数据操作语言(Data Manipulation Language)</li><li><strong>DCL:</strong> 数据控制语言(Data Control Language)</li><li><strong>DQL:</strong> 数据查询语言(Data Query Language)</li></ul><p>准则表明一个关系型数据库应该具有ACID特性，即：</p><ul><li><strong>Atomicity:</strong> 原子性</li><li><strong>Consistency:</strong> 一致性</li><li><strong>Isolation:</strong> 隔离性</li><li><strong>Durability:</strong> 持久性</li></ul><p>因为这些特性比较重要，下面做一些说明。</p><p><strong>数据库事务</strong></p><p>数据库事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列完成（注意：这个和日常生活中的事务是有区别的。）它是数据库执行的基础。</p><p><strong>原子性</strong></p><p>它要求数据库事务执行要么成功要么失败，不存在部分成功或者失败，即事务要求作为一个整体来执行。也就是意味着事务的不可分割性和不可约性。</p><p><strong>一致性</strong></p><p>它要求数据库事务的执行应该确保数据库状态从一个一致性状态转变为另一个一致性状态。这里的一致性是指所有数据必须满足完整性约束（比如数据类型定义，触发器，主键约束等）。</p><p><strong>隔离性</strong></p><p>它要求多个数据库事务的并发执行时能够得到正确的结果，即要求进行正确的并发控制。</p><p><strong>持久性</strong></p><p>它要求数据库事务一旦执行完毕并提交，就应该永久保存在数据库中。即数据必须记录到非易失性存储上，另一方面，它要求数据库具有错误恢复能力。</p><p>这些特性赋予了关系型数据库很强的数据管理能力，多用户的支持、安全审计、异常恢复等其它特性，使得它成为了使用范围最广影响最深的一类数据库。下面是一个关系型数据库的基本结构：</p><img src="/thinking-in-bigdata/RDBMS_structure.png" title="RDBMS_structure"><p>一些常见的关系型数据库：</p><ul><li>商业：Oracle DB, Microsoft SQL Server, DB2, Sybase, …</li><li>开源：MySQL, PostgreSQL, Apache Derby, HSQLDB, H2, …</li></ul><p><em>扩展阅读</em>：</p><ul><li>常见关系型数据库列表：<a href="https://en.wikipedia.org/wiki/List_of_relational_database_management_systems" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/List_of_relational_database_management_systems</strong></a></li><li>常见关系型数据库列表比较：<a href="https://en.wikipedia.org/wiki/Comparison_of_relational_database_management_systems" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Comparison_of_relational_database_management_systems</strong></a></li></ul><p><strong>但辉煌之下，一场危机正在酝酿。</strong></p><p>上个世纪90年代开始，面向对象编程开始兴起。随着越来越多的系统使用OO构建，人们发现将内存中的对象数据持久化到关系型数据库中存在一些障碍，两种模式似乎无法兼容（具体可以参考相应的维基百科词条<a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch</strong></a>）。人们将这种现象称之为<strong>Object-relational impedance mismatch</strong>，即“阻抗失衡”。一些ORM工具和框架被创造出来，试图解决这些问题。</p><p>另一方面，随着互联网快速发展，数据的量和形式都空前的大。加上昂贵的授权和维护费用，使得越来越多的企业开始寻求性价比更高的解决方案。</p><img src="/thinking-in-bigdata/Hilbert_InfoGrowth.png" title="Hilbert_InfoGrowth"><p>随着时代的发展，数据产生场景不断发生变化，数据格式形态也变得越来越丰富。从结构化的角度大致可以分为：</p><ul><li>结构化数据：有明确的结构定义，且结构稳定良好的数据。比如，常见的关系型数据库存储的数据</li><li>半结构化数据：有一定的结构，但结构易变的数据。比如，HTML，XML，JSON类数据</li><li>非结构化数据：没有明确的结构定义或者不易结构化的数据，比如图片、文本、音频、视频等</li></ul><p>大数据时代来临了，但现有的关系型数据库在可扩展性方面出奇的差，面对数据量不断增长(特别是半结构化和非结构化数据的增长)的需求和硬件技术发展的瓶颈，现有的关系型数据库已经力不从心了。</p><p>不可否认的是，关系型数据库依然是目前应用最广的数据库，在处理中小数据的时候仍然是优先考虑的选择。</p><h4 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h4><p>首先，对于<strong>NoSQL</strong>这个词并没有一个权威的定义，你可以理解为”non sql”, “non relational”或者”not only sql”。它不是指一种特定的技术或者数据模型，而是对有别于关系型数据库的那类数据库的总称。这些NoSQL数据库的诞生不仅弥补之前关系型数据库的可扩展性问题，而且提高了一些新的数据存储方式。</p><p>NoSQL数据库由于采用聚合形式的数据存储，可以很方便地进行数据分布，因此都采用了横向扩展。一般可以通过两种途径实现数据分布化：</p><ul><li><strong>sharding:</strong> 实现了数据分片，提高了数据存储容量，提高了数据的可用性，但一致性下降</li><li><strong>replication:</strong> 实现了数据的复制，提高了数据的读取性能和系统的健壮性。一般有良好的一致性，但可用性下降。</li></ul><p>这两种技术相铺相成，即它们是正交的。使用时，比较灵活，可以根据具体情况和要求搭配使用。常见的做法有：</p><ul><li>单机</li><li>分片</li><li>主从复制</li><li>对等复制</li><li>分片和复制混合</li></ul><h5 id="有哪些NoSQL数据库"><a href="#有哪些NoSQL数据库" class="headerlink" title="有哪些NoSQL数据库"></a><strong>有哪些NoSQL数据库</strong></h5><p>NoSQL数据库最大的特点就是放弃了关系模型中的元组结构，采用了另外一些宽松的，结构更加复杂的结构。根据这些结构的不同可以将这些数据库分为：</p><ul><li>键值数据库：Redis, Riak, Memcached(及其变种), Berkeley DB, Amazon DynamoDB， Google LevelDB</li><li>文档数据库：MongoDB, CouchDB, Terrastore</li><li>列族数据库：HBase, Cassandra, Amazon SimpleDB</li></ul><p>这些数据库操作数据所用的基本单位不再是元组，而是各自定义的复杂结构（可以称之为聚合）。这种数据的存储方式使得特定情况下，由于不需要额外的JOIN过程，数据的获取变得很高效。另外，他们是无模式的，不需要事先定义结构，可自由添加字段，这对于处理半结构化或者非结构化数据非常有用。</p><p>还有一类数据库提供了另外一种数据模型</p><ul><li>图数据库：Neo4j, Infinite Graph, OrientDB, FlockDB</li></ul><p>其他的还有比如对象型数据库，基于云的数据库等，具体可以参考相应的维基百科词条<a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/NoSQL</strong></a></p><h4 id="这些NoSQL数据库什么时候用"><a href="#这些NoSQL数据库什么时候用" class="headerlink" title="这些NoSQL数据库什么时候用"></a><strong>这些NoSQL数据库什么时候用</strong></h4><p>由于CAP约束的存在，各个数据库在实现上面临着取舍，各自专注的领域有所区别。下面介绍一下各种NoSQL数据库的常见的应用场景：</p><img src="/thinking-in-bigdata/CAP.png" title="CAP"><p><em>关于一致性和可用性的更多讨论将在下一章详细说明。</em></p><p><strong>键值对类型</strong></p><p>键值对顾名思义其数据存储采用键值形式进行。用户可以根据键来查询、设置或者删除对应的值，这个和编程中经常使用的HashMap类似，区别在于这里的值对于数据库而言只是一块数据，其格式和结构可以不一致的，即数据库不关心存储在值中的内容。这个需要应用程序负责解释。还有一些键值数据库(比如Redis)支持范围查询，集合操作等。</p><p>目前使用较多或者市场份额加大的有：Riak，Redis和Memcached DB。下面以这些数据库为例做一下说明：</p><p>先对这些数据库做一下简介</p><ol><li><strong>Redis:</strong> 是一个开源的(基于BSD协议)、支持网络、基于内存的键值对存储(又称为数据结构存储)，使用ANSI-C实现。其中值支持丰富的数据结构(string, list, set , hash tables…)，可用作数据库、缓存或者消息代理。支持分片、事务、LRU缓存、Lua脚本和不同级别的磁盘持久化。通过<code>Redis Sentinel</code>提供高可用性，使用<code>Redis Cluster</code>来实现集群管理。它是目前最流行的键值对存储数据库。官方网站：<a href="https://redis.io" target="_blank" rel="noopener"><strong>https://redis.io</strong></a></li><li><strong>Riak:</strong> 是具有高可用性、容错强、操作简单及扩展性特点的一个分布式键值对数据库。使用Erlang语言实现，它是<code>Amazon Dynamo</code>的开源实现。支持数据分片和集群部署。官方网站：<a href="http://basho.com/products/" target="_blank" rel="noopener"><strong>http://basho.com/products/</strong></a></li><li><strong>Memcached:</strong> 是一个开源的(基于BSD协议)高速缓存系统。它使用C语言实现。其API使用哈希算法计算键值后，将数据分散在不同机器的哈希表中。这个表支持LRU的缓存策略。它通常被作为缓存系统使用，尤其对于请求量大或者生成内容成本高的系统有很好的性能提升作用。但是，它缺乏持久化机制，需要额外的代码实现。另外，它缺乏认证和安全管制，所以一般需要放置在安全可信的网络中。另外，<strong>MemcacheDB</strong>和<strong>CouchBase</strong>都是它的变种，它们提供了持久化能力，并且和Memcached具有协议兼容性。官方网站：<a href="https://memcached.org/" target="_blank" rel="noopener"><strong>https://memcached.org/</strong></a></li></ol><p>键值数据库特性：</p><ol><li><strong>一致性</strong></li></ol><p>只有针对单个键的操作才具备强一致性，对于采用分布式的情况，可以提供最终一致性。当然，这边就需要在读取或者写入效率做出取舍。</p><ul><li>Redis: 支持主从复制，支持最终一致性</li></ul><p>键值数据库在做分片时，一般按照键进行，如何生成合适的键来满足分片的需求？</p><blockquote><p>一致性哈希</p></blockquote><ol start="2"><li><p><strong>事务</strong></p></li><li><p><strong>查询</strong></p></li><li><p><strong>可扩展性</strong></p></li></ol><p>关于分片</p><p>分片实现方式</p><p>分片的优缺点</p><ol start="5"><li><strong>适用案例</strong></li></ol><p>这一类数据库一般采用内存存储策略（所以也可以称之为内存键值数据库），强调高性能。支持各种内存数据结构，对数据结构要求宽松。</p><ul><li>存放用户会话信息</li><li>用户配置信息</li><li>购物车信息</li></ul><ol start="6"><li><strong>不适用的场合</strong></li></ol><ul><li>数据间存在关系</li><li>含有多项操作的事务：比如需要同时更新多个键值对</li><li>需要根据值来查询数据：当然我们也可以使用Solr这样的索引引擎来提供检索功能</li><li>集合操作：由于键值数据库一次只能操作一个键，所以它无法操作多个关键字。对于多个关键字，可以在客户端处理</li></ul><p>使用时我们需要注意几点：</p><ul><li>键的选择或者生成</li><li>存储的数据是否重要，能否忍受数据的丢失，是否需要持久化</li><li>使用键查询时，是否存在不知道键的情况。是否需要支持键的搜索</li><li>对一致性的要求怎么样，强一致性还是最终一致性，一致性窗口多大？</li></ul><p>各个键值数据库之间由于关注点和应用差异，存在或多或少的区别。实际应用时，需要根据实际情况和各个数据库官方说明选择合适的数据库和配置。</p><p><strong>文档类型</strong></p><p><strong>列族类型</strong></p><p><strong>图类型</strong></p><p>这个类型比较特殊，它和上面的区别在于其并不是为了解决大数据量的问题</p><p>他们之间更详细的比较可以参考<a href="https://en.wikipedia.org/wiki/Comparsion_of_structured_storage_software" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Comparsion_of_structured_storage_software</strong></a>。</p><p>由于NoSQL数据库中大多都能够实现数据的分布化，因此原来的<strong>ACID</strong>特性不再适用，取而代之的是<strong>BASE</strong>。即：</p><ul><li><strong>Basically Available:</strong> 基本可用</li><li><strong>Soft state:</strong> 软状态</li><li><strong>Eventual consistency:</strong> 最终一致性</li></ul><p>可以看出，这里通过牺牲了严格的可用性和一致性，来换取可扩展性。</p><h4 id="NewSQL数据库"><a href="#NewSQL数据库" class="headerlink" title="NewSQL数据库"></a>NewSQL数据库</h4><p>兼顾扩展性和ACID保证的现代关系型数据库</p><ol><li>全新类型的数据库系统<ul><li>Google Spanner</li><li>Clustrix</li><li>VoltDB</li><li>MemSQL</li><li>NuoDB</li><li>…</li></ul></li><li>对数据库引擎进行了优化<ul><li>MySQL Cluster</li><li>TokuDB</li><li>…</li></ul></li></ol><p>这类系统都提供了分片的中间件成，用来对数据库进行分割，以便在多个节点上运行</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>上面我们说得数据库可以都归为结构化存储，他们对于结构化或者部分半结构化数据往往具有较好的管理。但对于非结构化数据就无能为力了，因此亟需一种数据管理系统能够对非结构化数据进行处理。</p><p>Riak支持Solr</p><p>全文检索</p><h3 id="2-数据库的使用模式"><a href="#2-数据库的使用模式" class="headerlink" title="2. 数据库的使用模式"></a>2. 数据库的使用模式</h3><p>数据库屏蔽，服务化<br>交互形式：Rest HTTP,Protobuf，Thrift…</p><p>这是一个螺旋上升的过程，NoSQL本身不是SQL的取代，只是在特定邻域或者场景下的妥协和特化。如何组织数据中的关系是演变的核心。</p><h2 id="三、计算"><a href="#三、计算" class="headerlink" title="三、计算"></a>三、计算</h2><p>操作系统类比</p><p>有时计算复杂度较低，但数据量加大，导致总体计算量大；有时计算复杂度高，数据量不一定大，但计算量同样很大。</p><p>关系型数据库访问方式</p><p>客户端 vs 服务端</p><p>计算模型：</p><p>SISD, SIMD, MISD, MIMD</p><p>并发/并行 vs 分布</p><p>计算伴随着数据的分布化而分布化</p><p>数据索引</p><p>分布式中的算法及其应用场景</p><p>计算场景：</p><ul><li>实时应用：在线系统、实时分析、CEP。可使用的计算框架：Storm, S4, Cloudera Impala, Apache Drill</li><li>交互式应用：可视化、向下钻取、探索、定制化报表。可使用的计算框架：Cloudera Impala, Apache Drill, Shark</li><li>非交互式应用：数据准备、增量式批处理、Dashboard。可使用的计算框架：MapReduce, Hive, Pig, Stinger</li><li>批处理：批处理、数据挖掘。可使用的计算框架：MapReduce, Hive, Pig, Stinger</li></ul><p>作业管理</p><ul><li>Tez</li></ul><h2 id="四、Hadoop家族"><a href="#四、Hadoop家族" class="headerlink" title="四、Hadoop家族"></a>四、Hadoop家族</h2><p>存储</p><p>数据模型</p><p>集群管理</p><p>计算模型</p><p>任务管理</p><h2 id="附录-A"><a href="#附录-A" class="headerlink" title="附录 A."></a>附录 A.</h2><h3 id="1-分布式相关"><a href="#1-分布式相关" class="headerlink" title="1. 分布式相关"></a>1. 分布式相关</h3><p>面对数据量的不断增长，人们需要对现有的系统进行升级扩展以满足需求。这种扩展通常分为两种：</p><ul><li>纵向扩展(scale up)：通过升级CPU、内存、磁盘，甚至机器来获得整体性能提升，达到资源扩充的目的。但这种方式提升有限，且成本较高</li><li>横向扩展(scale out)：通过使用大量廉价的机器组建集群，实现分布式系统，达到资源扩充的目的。但这种方式带来了集群管理的难题</li></ul><p>由于摩尔定律逐渐失效</p><img src="/thinking-in-bigdata/Moores_Law.png" title="Moores_Law"><p>单台计算机的性能提升幅度已经不能满足日益增长的数据，且成本高昂。因此横向扩展成了眼下可行的选择。特别是Google发表的《三大论文》，使得<strong>分布式计算</strong>的概念开始在互联网应用中盛行。当然，分布式概念本身不是一个新事物。比如因特网本身就是一个成功的巨型分布式应用，其它的还有DHT(分布式散列表，大家比较熟悉的应用BitTorrent就是基于此)，区块链(这个比较火)。我们这里讲的分布式主要是指用来大规模处理和存储海量数据。</p><p><em>扩展阅读</em>：</p><p>分布式计算维基百科词条：<a href="https://en.wikipedia.org/wiki/Distributed_computing" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Distributed_computing</strong></a></p><h4 id="分布式计算中的谬误"><a href="#分布式计算中的谬误" class="headerlink" title="分布式计算中的谬误"></a>分布式计算中的谬误</h4><p>由前Sun公司<code>L. Peter Deutsch</code>和几位核心创始人在1994年提出的，关于分布式应用中新手编程人员经常做的一些错误假设。其中第八点由<code>James Gosling</code>(Java之父)及其他几位Sun的核心人员在1997年补充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分布式计算中的谬误</span><br><span class="line"></span><br><span class="line">1. 网络是可靠的</span><br><span class="line">2. 没有延迟</span><br><span class="line">3. 无限带宽</span><br><span class="line">4. 网络是安全的</span><br><span class="line">5. 拓扑是不变的</span><br><span class="line">6. 只有一个管理员</span><br><span class="line">7. 没有传输成本</span><br><span class="line">8. 网络是同质的</span><br></pre></td></tr></table></figure><p><strong><a href="https://blogs.oracle.com/jag/resource/Fallacies.html" target="_blank" rel="noopener">https://blogs.oracle.com/jag/resource/Fallacies.html</a></strong></p><p>它表明构建一个健壮的分布式系统不是一件容易的事。</p><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><p>加州伯克利大学计算机科学家<code>Eric Brewer</code>首次在1998年提出了著名的<strong>CAP理论</strong>，该理论指出对于一个分布式计算系统不能同时提供以下三种保证：</p><ul><li><strong>Consistency:</strong> 一致性。包括读取一致性，更新一致性。即访问所有节点都会得到同一份最新的数据副本。</li><li><strong>Availability:</strong> 可用性。如果可以和集群中某个节点通信(该节点能够正常通信)，那么该节点就必然能够处理读取及写入操作。即对数据更新具有高可用性</li><li><strong>Partition tolerance:</strong> 分区容忍性。如果发生通信故障，导致整个集群分割成多个无法互相通信的分区时，集群仍然可以使用。</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不能同时满足全部的三项。这里引用维基百科上的例子简单解释一下：</p><blockquote><p>可以想象两个节点分别处在分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据的一致性，将分区一侧的节点设置为不可用，那么又会丧失了A性质。除非两个节点可以互相通信，才能既保证C又能保证A，这又会导致丧失P性质。</p></blockquote><p>这里有一些容易产生误解的地方，说明一下。</p><ol><li>误解一：关于可用性的含义。这里的可用性和通常意义上的定义有所差别。它指出必须能够在可接受的响应时间内进行读取和更新。</li><li>误解二：关于CAP三点的组合问题。这里不是简单的三选二，比如要想构建具备CA的系统，就意味着一旦系统中出现分区，那么所有的节点必须全部停止工作。这个前提是系统实时能够检测到分区是否出现，由于分布式系统的特性(后面会具体讲解)，这个操作几乎是不可能完成的。因此，对于集群来说必须要容忍分区的情况。当分布式系统发生了分区时，必须就当前的操作在C和A之间做出选择。</li></ol><p>当然，所谓的CAP理论并不是一个严格的数学证明，存在比较大的争议。具体落地时，需要根据实际情况去理解。</p><p><em>扩展阅读</em>：</p><ul><li>CAP理论：<a href="https://people.eecs.berkeley.edu/~brewer/cs252b-2004/PODC-keynote.pdf" target="_blank" rel="noopener"><strong>https://people.eecs.berkeley.edu/~brewer/cs252b-2004/PODC-keynote.pdf</strong></a>和<a href="http://www.glassbeam.com/sites/all/themes/glassbeam/images/blog/10.1.1.67.6951.pdf" target="_blank" rel="noopener"><strong>http://www.glassbeam.com/sites/all/themes/glassbeam/images/blog/10.1.1.67.6951.pdf</strong></a></li><li>CAP通俗讲解：<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener"><strong>http://ksat.me/a-plain-english-introduction-to-cap-theorem/</strong></a>和<a href="https://dzone.com/articles/better-explaining-cap-theorem" target="_blank" rel="noopener"><strong>https://dzone.com/articles/better-explaining-cap-theorem</strong></a></li><li>CAP历史：<a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="noopener"><strong>http://blog.csdn.net/chen77716/article/details/30635543</strong></a></li></ul><h4 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h4><p><strong>PACELC理论</strong>是对之前的CAP理论的一种扩展，由<code>Daniel J. Abadi</code>首次在2010年的博客中提及。该理论指出一个已存在网络分区(Partition)的分布式计算系统，仅能在一致性(Consistency)和可用性(Availability)之间选择一个(即CAP理论), 但是(Else),即使该系统在正常运行不存在分区的情况下，那它也必须在延迟(Latency)和一致性(Consistency)之间做出选择。</p><p>PACELC对分布式系统中潜在的一致性权衡问题，提供了一个更加完整的描述。它说明一个高可用的系统必须实现数据的复制，而一旦分布式系统复制数据，一致性和延迟之间的权衡就会出现。这一点已经从CAP理论的说明中略见端倪。</p><p><em>扩展阅读</em>：</p><ul><li>那篇博客：<a href="http://dbmsmusings.blogspot.ie/2010/04/problems-with-cap-and-yahoos-little.html" target="_blank" rel="noopener"><strong>http://dbmsmusings.blogspot.ie/2010/04/problems-with-cap-and-yahoos-little.html</strong></a></li><li>论文：<a href="http://cs-www.cs.yale.edu/homes/dna/papers/abadi-pacelc.pdf" target="_blank" rel="noopener"><strong>http://cs-www.cs.yale.edu/homes/dna/papers/abadi-pacelc.pdf</strong></a></li></ul><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p><strong>简介</strong></p><p>有过多线程编程经验的人知道，要想维护数据的一致性，同步是必不可少的手段。而在分布式系统中这一情况更加复杂，正如上面谬误中所指出的那样。网络延迟或者故障会导致更新丢失，操作顺序的不一致问题。因此，要想了解分布式系统中的一致性模型，我们就需要先理解其中的时间、事件和顺序问题。</p><p>这里的时间指系统中事件发生的物理时间和逻辑时间。先来解释一下物理世时间，在现实生活中，一个事件的发生不是一瞬间的事情，它应该有一个起始时间和结束时间。由于这个原因，多个事件的在物理时间上就有可能存在重叠，这一点在多线程里面就很常见。</p><p>但是，由于分布式系统的特性，系统中的物理时间很难同步。原因在于信息的传播速度是有极限的，即光速。因此分布式系统中每个节点的时间参考系都是独立的，这就造成物理时间的不同步。也就是说通过物理时间来实现一致性，理论上是不可能的。但是，有时候我们更关心事件的逻辑顺序（比如因果关系），不一定需要怎么严格的一致性。</p><p><code>Lamport Clock</code>是一种用于分辨分布式系统中的事件因果关系的算法，这是一种表达逻辑时间的逻辑时钟。它能够找到所有的历史事件的偏序关系，而且这种关系不仅仅在各自节点的逻辑时间参考系内顺序一致，同时全局上的顺序也是一致的。这个影响了后来很多一致性算法，比如<code>Vector Clock</code>, <code>Paxos</code>, <code>Raft</code>等。</p><p><em>扩展阅读</em>：</p><ul><li>Lamport Clock相关论文《Time, Clock and Ordering of Events in a Distributed System》：<a href="http://amturing.acm.org/p558-lamport.pdf" target="_blank" rel="noopener"><strong>http://amturing.acm.org/p558-lamport.pdf</strong></a></li><li>关于Vector Clock算法：<ul><li>《Why Vector Clocks Are Easy》:<a href="http://basho.com/posts/technical/why-vector-clocks-are-easy/" target="_blank" rel="noopener"><strong>http://basho.com/posts/technical/why-vector-clocks-are-easy/</strong></a></li><li>《Why Vector Clocks Are Hard》:<a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/" target="_blank" rel="noopener"><strong>http://basho.com/posts/technical/why-vector-clocks-are-hard/</strong></a></li></ul></li></ul><p><strong>Replication</strong></p><p>由于分布式系统本身的特性，随着系统的扩展，故障发生率上升以及性能问题。此时我们往往通过数据在多个节点备份方式，称为<code>Replication</code>。这个很容易理解，如果一个节点出现故障，可以迅速切换使用备份节点上复制的数据。由于存在多份复制数据，因此一个处理可以选择最近的副本，甚至就在本地，这有效地提高了性能。复制通常作为一种提高扩展性技术使用。</p><p>但是，复制的副本越多所需要越多的网络带宽，特别是当副本数量远低于使用到的数量时，会造成大量浪费。另外更严重的问题是要在多份副本间维持一致性。这要求读取所有的副本时获取到的值应该相同。更新则要求在进行任何其它操作前，更新所有的副本，不论它操作的是哪个副本，也就是它必须是一个原子性操作。这种使得维持所有副本的一致性代价是高昂的。</p><p>一方面，希望通过复制来解决扩展性问题，提升性能；但是，另一方面，为了保持所有副本的一致性就需要全局同步， 而这又降低了系统性能。甚至，这部分代价可能会高于其所带来的提升。因此，实际应用时，我们往往需要放宽一致性约束。这个也是之前的理论所指出的。</p><p><strong>一致性模型</strong></p><p>这边介绍几种常见的一致性模型：</p><ul><li>严格一致性：它要求读取的数据总是最近写入的数据，不存在更新后两次读取的值不一致的情况。比如说一个节点的数据更改，瞬时被另一个节点所感知，显然这种在分布式系统中是无法实现的。</li><li>顺序一致性：它关心的是事件发生的顺序，包含两个方面<ul><li>事件历史发生顺序在各个处理进程上看是全局一致的。比如有两个进程分别同时处理同一个数据，进程A的处理顺序有B-&gt;A-&gt;C，那么进程B的处理顺序也必须是B-&gt;A-&gt;C，但不要求这些处理过程发生的顺序在物理时间上严格一致。</li><li>单个处理进程的历史事件在全局历史上应该符合程序要求的顺序。比如有两个进程：进程A包含的操作有[1,2,3,4]；进程B包含的操作有[5，6，7，8]。他们执行的时的全局事件历史，可能是[1,5,2,3,6,7,4,8]，或者[1,4,5,6,3,2,8]。其中的[1,5,2,3,6,7,4,8]是符合两个进程中程序要求的顺序，而[1,4,5,6,3,2,8]不符合，因为，进程A中要求[1,2,3,4]，而这里是[1,4,3,2]。</li></ul></li><li>线性一致性：它的一致性要强于顺序一致性，也叫强一致性或者原子一致性。这个是我们现在能够实现的最高级别的一致性模型。它是在前面的一致性模型的基础上加入了对时间顺序的要求，而这个不依赖全局物理时钟。比如：<ul><li><img src="/thinking-in-bigdata/Linerization.png" title="Linerization"></li></ul></li><li>因果一致性：是一种比顺序一致性要弱的模型，它主要区分了哪些操作是有因果关系的，哪些操作是无关的(而顺序一致性则要求所有的操作都是一致的)。只有存在因果关系的操作才要求所有进程以相同的次序看到，对于无因果关系的，并无次序保证。比如在分布式存储中，对于所有可能存在因果关系的写入操作，其发生的先后顺序对于系统中所有节点来说都是一样。并发写(不存在因果关系)则在不同节点上的执行顺序可能是不同的。</li><li>PRAM/管道一致性：在因果一致性模型上进一步弱化，也就是由一个处理进程完成的写入操作对于其他处理进程来说顺序是保证的。但是不同处理进程的写入操作之间无需保证顺序。</li><li>最终一致性：是一种较弱的一致性模型，也是目前使用最为广泛的一种模型。它保证一个给定数据项在没有新的更新的情况下，更新最终会扩散传播，使得数据达到最终一致性。此时对该数据项所有访问都会返回最新更新的值。也就是说需要容忍读取出的数据是陈旧的。它有以下几个具体实现：<ul><li>单调读一致性：它保证在一次处理中读到的数据总是不旧于上一次读取到的数据。对于分布式系统来讲，这些读取操作可能会访问不同的节点或者数据不同的副本。</li><li>单调写一致性：它保证在一次处理中写入数据完成后才能进行下一次写。对于分布式系统来讲，这些写入操作可能会操作不同的节点，对数据不同的副本，进行写入。</li><li>读不旧于写一致性：它保证在一次处理中读取到的数据，总是不旧于自身上一次写入的数据。即需要保证读写的顺序，在读之前，写入操作必须完成。对于分布式系统来讲，写入和读取操作可能不在同一个节点上，或者针对于数据的不同副本。</li><li>写不旧于读一致性：它保证在一次处理中写入的数据，总是不旧于自身上一次读取的数据。即读取数据后，后续的写入操作需要更新之前读取到的数据。对于分布式系统来讲，写入和读取操作可能不在同一个节点上，或者针对于数据的不同副本。</li></ul></li></ul><p><em>扩展阅读</em>：</p><ul><li>一致性模型维基百科词条：<a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Consistency_model</strong></a></li><li>分布式系统一致性的发展历史（一）：<a href="http://danielw.cn/history-of-distributed-system-1" target="_blank" rel="noopener"><strong>http://danielw.cn/history-of-distributed-system-1</strong></a></li></ul><p><strong>关于不一致</strong></p><p>实际情况中，我们往往需要忍受不一致性来满足可用性要求，那什么是不一致性？我们可以下三个维度来描述不一致性：</p><ul><li>数值偏差：副本中具有数值语义的数据在数值上存在差异，可分为绝对差异和相对差异</li><li>陈旧度偏差：副本中数据的最后更新时间或者次数存在差异</li><li>更新顺序偏差：副本中数据的更新操作顺序存在差异</li></ul><p>一致性模型的强弱可以通过这些偏差大小来反映。</p><h4 id="一致性算法"><a href="#一致性算法" class="headerlink" title="一致性算法"></a>一致性算法</h4><p>在将一致性算法前，我们先来了解一下，这些算法需要解决的问题。</p><p><strong>面临的问题</strong></p><p>首先，说明一下分布式系统中的几个基本概念：</p><p><em>网络模型</em></p><ul><li>同步网络：这里的同步和并发/并行编程中的同步或者同步调用不是一回事。它是指在这个网络中1)所有节点的时钟漂移有上限；2)网络传输时间有上限；3)所有节点的计算速度有一致。这就意味着各个节点是可预测的。然而，现实中是不存在这样的网络的，此模型一般用于理论研究中。</li><li>异步网络：它和同步网络模型相反，1)节点的时钟漂移无上限；2)消息传输延迟无上限；3)节点的计算速度不可预料。这个就是现实中的网络类型了。每个节点状态都是不可预料的。</li></ul><p><em>故障类型</em></p><p>以下给出分布式系统中比较常见故障的分类，这些故障在解决难度上从难到易：</p><ul><li><strong>byzantine failures:</strong> 即拜占庭故障。它指一个节点不会按照程序逻辑执行，对它调用返回的结果是随机或者混乱错误的。要想解决这类问题，需要同步网络，且故障节点必须少于1/3，这个是最广泛最难处理的情况。</li><li><strong>crash-recovery failures:</strong> 相比较之前，此类故障增加了一个限制，即节点总是按照程序逻辑执行，返回的结果是正确的。但是返回时间是不保证的，可能由于网络故障，节点crash了或者网络延迟了。对于crash，还分为健忘或者非健忘的。所谓健忘就是crash恢复后没有完整的保持crash之前的状态信息，非健忘的指这个节点crash之前把完整的状态信息持久化的存储上，恢复后能够根据之前保留的值继续执行。</li><li><strong>omission failures:</strong> 在<code>crash-recovery failuers</code>的基础上，增加了crash必须是非健忘的这一个限制。</li><li><strong>crash-stop failures:</strong> 也称为<code>crash failure</code>或者<code>fail-stop failures</code>，它在<code>omission failures</code>的基础上增加了一旦故障发生后必须停止响应的要求。比如一个节点内部出现故障后立即停止接受和发送所有消息，并且这些故障不会自动恢复。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">拜占庭将军问题：</span><br><span class="line"></span><br><span class="line">拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，每个军队都</span><br><span class="line">分隔很远，将军们之间只能通过信差来传递消息。</span><br><span class="line"></span><br><span class="line">在战争的时候，拜占庭军队内所有的将军们必需达成一致的共识，来决定是否有赢得机会后才会攻打敌人。但是，军队中可能</span><br><span class="line">存在叛徒，左右将军们的决定，扰乱军队整体的秩序。在商量共识时，结果可能并不代表大多数人的意见，贸然进攻的话战争</span><br><span class="line">会失败。这个时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此产生了。</span><br><span class="line"></span><br><span class="line">该问题可以看作是对现实世界问题的模型化，硬件错误，网络故障或者延迟，或者遭到恶意攻击，都会使得某个计算节点变得</span><br><span class="line">不可靠，也就是那个叛徒。</span><br></pre></td></tr></table></figure><p>具体可以查看：<a href="https://zh.wikipedia.org/zh-cn/拜占庭将军问题" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/拜占庭将军问题</a><br>那这些问题，我们是不是都能够解决呢？由于这些问题具有包含涵盖关系，所以如果最难的拜占庭故障能够解决，当然后面的故障类型就能够迎刃而解。</p><p>1985年横空出世的<code>FLP Impossibility</code>定理给出了答案，它指出在有限定条件的异步网络中，只要存在一个故障节点，任何一致性算法都无法保证正确结束。这些限定条件使得该理论的网络模型要比拜占庭故障中的模型要理想合严格很多。如果在这样理想的模型中，一致性问题都无法保证，那么在现实中更宽松的环境中当然更加不可能了。因此，一般我们只对异步且非拜占庭模型进行讨论。</p><p>在分布式系统中的故障是常态的，为了保证系统的稳定性和可用性，就要求系统必须具备<code>fault tolerence</code>。为了获得这种特性，一般采用<strong>replicated state machines</strong>的方法来达到，实际系统中一般使用replicated log作为具体实现。而维护这些log文件的一致性就用到了一致性算法。而一个一致性算法应该具有以下特点：</p><ul><li>它在所有非拜占庭条件下保证safety(不会返回不正确的结果)，所谓非拜占庭条件是指网络延迟，分区以及数据包丢失，重复或者乱序</li><li>它需要保证系统中半数以上的节点完全可用的，包括它们内部之间以及和客户端之间的通信。另外，所有的节点都应该是故障停机的，且是非健忘的，后期恢复后，可以重新加入到集群中。</li><li>算法不依赖具体时间来维持一致性，它主要工作的网络模型为异步的。</li><li>通常情况下，一个命令能够在系统中大多数节点上以单个RPC完成。</li></ul><p>这里提一下safety和liveness这两个特性:</p><ul><li>safety：安全性，它是指在分布式系统中一个变量一旦被决定为某个值比如A，那么就不会再有其他决定来更改这个值</li><li>liveness：活性，它是指分布式系统中一个变量被决定为某个值的过程总是能够成功</li></ul><p>它们是分布式系统算法中的两个死对头，就像之前的一致性和可用性一样，两者是对立的。而且FLP定理指出，在异步网络中是没有完全同时保证safety和liveness的一致性算法。因此，后面我们提到的一致性算法，实现时往往放松了liveness的要求。这些算法可能会进入无限循环，但概率非常非常低。</p><p><em>扩展阅读</em>：</p><ul><li>分布式系统一致性的发展历史（二）：<a href="http://danielw.cn/history-of-distributed-system-2" target="_blank" rel="noopener"><strong>http://danielw.cn/history-of-distributed-system-2</strong></a></li><li>Distributed Systems, Failures, and Consensus：<a href="https://www.cs.duke.edu/courses/fall07/cps212/consensus.pdf" target="_blank" rel="noopener"><strong>https://www.cs.duke.edu/courses/fall07/cps212/consensus.pdf</strong></a></li><li>Consensus维基百科：<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Consensus_(computer_science)</strong></a></li><li>FLP Impossibility：<a href="http://danielw.cn/FLP-proof" target="_blank" rel="noopener"><strong>http://danielw.cn/FLP-proof</strong></a></li></ul><p><strong>Paxos</strong></p><p>首先，这里定义三种角色：</p><ul><li>proposers：负责提出建议值</li><li>acceptors：决定是否接受给定的建议值</li><li>learners：不参与提议和决策过程但需要知道最终结果</li></ul><p>最简单的方式就是一个proposer发送一个候选值到一个acceptor，而该acceptor会选择它接受到的第一个候选值。但是，一旦这个acceptor出现故障，那么后续的处理就不可能了。</p><p>既然一个acceptor不行的话，那我用多个acceptor吧。一个proposer将发送一个候选值发送给这些acceptor，如果被半数以上acceptor收到的话，就将其选为最终结果。当然，这个前提是一个acceptor必须接受其收到的第一个候选值。那如果有多个候选值同时被多个proposer发送，这种情况下就没有办法给出最终结果。因为此时每个候选值得acceptor数可能不过半。</p><p>现在，我们改变一下策略，允许一个acceptor可以接收多个候选值。这里我们给每个候选值赋予一个独一无二的编号，这样每个候选值就由编号和具体值组成。</p><p><em>扩展阅读</em>：</p><ul><li>Paxos算法维基百科：<a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" target="_blank" rel="noopener"><strong>https://en.wikipedia.org/wiki/Paxos_(computer_science)</strong></a></li><li>Paxos Made Simple：<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener"><strong>http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf</strong></a></li><li>Paxos通俗讲解：<ul><li><a href="http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html" target="_blank" rel="noopener"><strong>http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html</strong></a></li><li><a href="http://blog.csdn.net/chen77716/article/details/6166675" target="_blank" rel="noopener"><strong>http://blog.csdn.net/chen77716/article/details/6166675</strong></a></li><li><a href="http://blog.csdn.net/chen77716/article/details/6170235" target="_blank" rel="noopener"><strong>http://blog.csdn.net/chen77716/article/details/6170235</strong></a></li><li><a href="http://blog.csdn.net/chen77716/article/details/6172392" target="_blank" rel="noopener"><strong>http://blog.csdn.net/chen77716/article/details/6172392</strong></a></li></ul></li></ul><p><strong>Raft</strong></p><p>具体可参考<a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p><p><em>扩展阅读</em>：</p><ul><li>Raft作者博士论文：<a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener"><strong>https://ramcloud.stanford.edu/~ongaro/thesis.pdf</strong></a></li><li>Raft在线演示：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener"><strong>http://thesecretlivesofdata.com/raft/</strong></a></li></ul><p><strong>其它</strong></p><ul><li>ZAB：Zookeeper Atomic Broadcast，是Zookeeper中实现的一致性算法</li><li>ViewStamp：可能是最早实现的一致性算法</li></ul><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li>《NoSQL distilled: A Brief Guide to the Emerging World of Polyglot Persistence》：<a href="https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620" target="_blank" rel="noopener"><strong>https://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620</strong></a></li><li>《Seven Databases in Seven Weeks: A Guide to Modern Databases and the NoSQL Movement》：<a href="https://www.amazon.com/Seven-Databases-Weeks-Modern-Movement/dp/193435691" target="_blank" rel="noopener"><strong>https://www.amazon.com/Seven-Databases-Weeks-Modern-Movement/dp/193435691</strong></a></li><li>《Sams teach yourself SQL in 10 minutes》：<a href="https://www.amazon.com/SQL-Minutes-Sams-Teach-Yourself/dp/0672336073" target="_blank" rel="noopener"><strong>https://www.amazon.com/SQL-Minutes-Sams-Teach-Yourself/dp/0672336073</strong></a></li><li>《Distributed Systems: Principles and Paradigms》：<a href="https://www.amazon.com/Distributed-Systems-Principles-Paradigms-2nd/dp/0132392275" target="_blank" rel="noopener"><strong>https://www.amazon.com/Distributed-Systems-Principles-Paradigms-2nd/dp/0132392275</strong></a></li><li>《Database System Concepts》：<a href="https://www.amazon.com/Database-System-Concepts-Abraham-Silberschatz/dp/0073523321" target="_blank" rel="noopener"><strong>https://www.amazon.com/Database-System-Concepts-Abraham-Silberschatz/dp/0073523321</strong></a></li><li>《Hadoop: The Definitive Guide》：<a href="https://www.amazon.com/Hadoop-Definitive-Guide-Tom-White/dp/1491901632" target="_blank" rel="noopener"><strong>https://www.amazon.com/Hadoop-Definitive-Guide-Tom-White/dp/1491901632</strong></a></li><li>《The Google File System》：<a href="http://research.google.com/archive/gfs-sosp2003.pdf" target="_blank" rel="noopener"><strong>http://research.google.com/archive/gfs-sosp2003.pdf</strong></a></li><li>《MapReduce: Simplified Data Processing on Large Clusters》：<a href="http://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener"><strong>http://research.google.com/archive/mapreduce-osdi04.pdf</strong></a>(<a href="http://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">http://research.google.com/archive/mapreduce-osdi04.pdf</a>)</li><li>《BigTable: A Distributed Storage System for Structured Data》：<a href="http://research.google.com/archive/bigtable-osdi06.pdf" target="_blank" rel="noopener"><strong>http://research.google.com/archive/bigtable-osdi06.pdf</strong></a>(<a href="http://research.google.com/archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">http://research.google.com/archive/bigtable-osdi06.pdf</a>)</li><li>《The Chubby lock service for loosely-coupled ditributed systems》：<a href="http://research.google.com/archive/chubby-osdi06.pdf" target="_blank" rel="noopener"><strong>http://research.google.com/archive/chubby-osdi06.pdf</strong></a>(<a href="http://research.google.com/archive/chubby-osdi06.pdf" target="_blank" rel="noopener">http://research.google.com/archive/chubby-osdi06.pdf</a>)</li><li>《Finding a Needle in Haystack: Facebook’s Photo Storage》：<a href="https://research.facebook.com/publications/finding-a-needle-in-haystack-facebook-s-photo-storage/" target="_blank" rel="noopener"><strong>https://research.facebook.com/publications/finding-a-needle-in-haystack-facebook-s-photo-storage/</strong></a></li><li>《Windows Azure Storage: a highly avaliable cloud storage service with strong consistency》：<a href="https://azure.microsoft.com/zh-cn/blog/sosp-paper-windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency/" target="_blank" rel="noopener"><strong>https://azure.microsoft.com/zh-cn/blog/sosp-paper-windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency/</strong></a></li><li>《GraphLab: A New Framework for Parallel Machine Learning》：<a href="http://www.select.cs.cmu.edu/publications/paperdir/fuai2010-low-gonzalez-kyrola-bickson-guestrin-hellerstein.pdf" target="_blank" rel="noopener"><strong>http://www.select.cs.cmu.edu/publications/paperdir/fuai2010-low-gonzalez-kyrola-bickson-guestrin-hellerstein.pdf</strong></a></li><li>《Resilient Distriubted Datasets: A Fault-Tolerent Abstraction for In-memory Cluster Computing》：<a href="http://www-bcf.usc.edu/~minlanyu/teach/csci599-fall12/papers/nsdi_spark.pdf" target="_blank" rel="noopener"><strong>http://www-bcf.usc.edu/~minlanyu/teach/csci599-fall12/papers/nsdi_spark.pdf</strong></a></li><li>《Scaling Distributed Machine Learning with the Parameter Server》：<a href="https://www.cs.cmu.edu/~muli/file/parameter_server_osdi14.pdf" target="_blank" rel="noopener"><strong>https://www.cs.cmu.edu/~muli/file/parameter_server_osdi14.pdf</strong></a></li><li>《Dremel: Interative Analysis of Web-Scale Datasets》：<a href="https://research.google.com/pubs/archive/36632.pdf" target="_blank" rel="noopener"><strong>https://research.google.com/pubs/archive/36632.pdf</strong></a></li><li>《Pregel: a system for large-scale graph processing》：<a href="https://www.cs.cmu.edu/~pavlo/courses/fall2013/static/papers/p135-malewicz.pdf" target="_blank" rel="noopener"><strong>https://www.cs.cmu.edu/~pavlo/courses/fall2013/static/papers/p135-malewicz.pdf</strong></a></li><li>《Spanner: Google’s Globally-Distributed Database》：<a href="http://research.google.com/archive/spanner-osdi2012.pdf" target="_blank" rel="noopener"><strong>http://research.google.com/archive/spanner-osdi2012.pdf</strong></a></li><li>《Dynamo: Amazon’s Highly Available Key-Value Store》：<a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener"><strong>http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf</strong></a></li><li>《S4: Distributed Stream Computing Platform》：<a href="http://cs.brown.edu/~debrabant/cis570-website/papers/s4.pdf" target="_blank" rel="noopener"><strong>http://cs.brown.edu/~debrabant/cis570-website/papers/s4.pdf</strong></a></li><li>《Storm @Twitter》：<a href="http://cs.brown.edu/courses/csci2270/archives/2015/papers/ss-storm.pdf" target="_blank" rel="noopener"><strong>http://cs.brown.edu/courses/csci2270/archives/2015/papers/ss-storm.pdf</strong></a></li><li>更多请参考：<ul><li><a href="https://www.linkedin.com/pulse/100-open-source-big-data-architecture-papers-anil-madan" target="_blank" rel="noopener"><strong>https://www.linkedin.com/pulse/100-open-source-big-data-architecture-papers-anil-madan</strong></a></li><li><a href="http://www.dataguru.cn/article-9003-1.html" target="_blank" rel="noopener"><strong>http://www.dataguru.cn/article-9003-1.html</strong></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是本人在接触大数据过程中，对一些原理、概念以及当前常用实现技术的笔记和总结。本人接触大数据不深，实践不多，见识不广，如果错误或者偏颇之处，欢迎斧正。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;未完待续&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="big data" scheme="https://johntse.dev/categories/big-data/"/>
    
      <category term="thinking" scheme="https://johntse.dev/categories/big-data/thinking/"/>
    
    
      <category term="big data" scheme="https://johntse.dev/tags/big-data/"/>
    
      <category term="algorithm" scheme="https://johntse.dev/tags/algorithm/"/>
    
      <category term="hadoop" scheme="https://johntse.dev/tags/hadoop/"/>
    
      <category term="database" scheme="https://johntse.dev/tags/database/"/>
    
  </entry>
  
</feed>
